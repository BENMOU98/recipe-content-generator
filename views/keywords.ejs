<!-- Keywords management page -->
<div class="row mb-4">
  <!-- Stats Section -->
  <div class="col-md-12">
    <div class="card">
      <div class="card-header">
        <h5 class="card-title">Keywords Statistics</h5>
      </div>
      <div class="card-body">
        <div class="row">
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded">
              <h3><%= stats.total %></h3>
              <p class="mb-0">Total Keywords</p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded bg-warning bg-opacity-10">
              <h3><%= stats.pending %></h3>
              <p class="mb-0">Pending Keywords</p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded bg-success bg-opacity-10">
              <h3><%= stats.processed %></h3>
              <p class="mb-0">Processed Keywords</p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="stats-box text-center p-3 border rounded bg-danger bg-opacity-10">
              <h3><%= stats.failed %></h3>
              <p class="mb-0">Failed Keywords</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Process Keywords Section -->
  <div class="card mt-4">
    <div class="card-header">
      <h5 class="card-title">Process Keywords</h5>
    </div>
    <div class="card-body">
      <form id="processKeywordsForm">
        <div class="mb-3">
          <label class="form-label">Content Generation Options</label>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="contentOption" id="optionFacebook" value="facebook" checked>
            <label class="form-check-label" for="optionFacebook">
              Facebook & Midjourney
            </label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="contentOption" id="optionPinterest" value="pinterest">
            <label class="form-check-label" for="optionPinterest">
              Pinterest & Blog
            </label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="contentOption" id="optionAll" value="all">
            <label class="form-check-label" for="optionAll">
              All Content
            </label>
          </div>
        </div>

        
        <button type="button" id="processSelectedBtn" class="btn btn-success" disabled>
          Process Selected Keywords (<span id="selectedCount">0</span>)
        </button>
        <button type="button" id="processNextBtn" class="btn btn-primary">
          Process Next Pending Keywords
        </button>
      </form>
    </div>
  </div>
</div>

<div class="row">
  <!-- Add Keywords Section -->
  <div class="col-md-5">
    <div class="card">
      <div class="card-header">
        <h5 class="card-title">Add Keywords</h5>
      </div>
      <div class="card-body">
       <form id="addKeywordsForm" method="POST">
          <ul class="nav nav-tabs mb-3" id="inputTabs" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="manual-tab" data-bs-toggle="tab" data-bs-target="#manual" type="button" role="tab" aria-controls="manual" aria-selected="true">Manual Entry</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="excel-tab" data-bs-toggle="tab" data-bs-target="#excel" type="button" role="tab" aria-controls="excel" aria-selected="false">Excel Upload</button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="pinclicks-tab" data-bs-toggle="tab" data-bs-target="#pinclicks" type="button" role="tab" aria-controls="pinclicks" aria-selected="false">PinClicks Analysis</button>
            </li>
          </ul>
          
          <div class="tab-content" id="inputTabsContent">
            <!-- Manual Entry Tab -->
            <div class="tab-pane fade show active" id="manual" role="tabpanel" aria-labelledby="manual-tab">
  <div class="mb-3">
    <label for="keywords" class="form-label">Complete Recipes (One per entry, separated by "---")</label>
    <textarea class="form-control" id="keywords" name="keywords" rows="15" placeholder="Enter complete recipes separated by --- for example:
The Best Moist Chocolate Cake Recipe
Ingredients:
1 cup cake flour
1/3 cup cocoa powder
1 cup sugar
1/2 tsp salt
1 tsp baking powder
1 tsp baking soda
2 large eggs
1/2 cup full cream milk
1/4 cup vegetable oil
1 tsp vanilla extract
1/2 to 1 tsp coffee
1/2 cup boiling water
1 tbsp white vinegar
Instructions:
1. Preheat your oven to 175°C (350°F). Grease and flour a cake pan.
2. In a mixing bowl, sift together cake flour, cocoa powder, sugar, salt, baking powder, and baking soda.
3. Add eggs, milk, oil, and vanilla extract. Mix until well combined.
4. Dissolve coffee in boiling water and add to batter.
5. Stir in white vinegar and mix until fully incorporated.
6. Pour into prepared pan and bake for 40 minutes or until done.
---
Easy Chicken Alfredo Pasta
Ingredients:
2 chicken breasts
1 lb fettuccine pasta
1 cup heavy cream
1/2 cup parmesan cheese
2 cloves garlic
2 tbsp butter
Salt and pepper to taste
Instructions:
1. Cook pasta according to package directions.
2. Season and cook chicken until golden brown.
3. Make alfredo sauce with cream, garlic, and parmesan.
4. Combine everything and serve hot."></textarea>
  </div>
  
  <div class="mb-3">
    <label for="imageUrl" class="form-label">Reference Image URL</label>
    <input type="url" class="form-control" id="imageUrl" name="imageUrl" placeholder="https://example.com/image.jpg">
    <div class="form-text">Add a reference image URL for Midjourney</div>
  </div>
</div>

            <!-- Excel Upload Tab -->
            <div class="tab-pane fade" id="excel" role="tabpanel" aria-labelledby="excel-tab">
              <div class="mb-3">
                <label for="excelFile" class="form-label">Upload Excel File</label>
                <input type="file" class="form-control" id="excelFile" name="excelFile" accept=".xlsx, .xls, .csv">
                <div class="form-text">
                  Excel file should have columns with these headers:
                  <ul class="mt-2">
                    <li><strong>Keyword</strong> (required) - Recipe title OR complete recipe with ingredients and instructions</li>
                    <li><strong>Category</strong> (optional) - Recipe category</li>
                    <li><strong>ImageUrl</strong> (optional) - Reference image URL for Midjourney</li>
                    <li><strong>Interests</strong> (optional) - Target audience interests</li>
                  </ul>
                  <div class="alert alert-info mt-2">
                    <strong>💡 How it works:</strong>
                    <ul class="mb-0">
                      <li><strong>Simple keywords:</strong> "Chocolate Chip Cookies" → AI will generate the full recipe</li>
                      <li><strong>Complete recipes:</strong> Full recipe with ingredients and instructions → Stored as-is</li>
                    </ul>
                    The system automatically detects whether your Keyword column contains simple keywords or complete recipes!
                  </div>
                </div>
              </div>
              
              <div id="excelPreview" class="mb-3 d-none">
                <h6>Excel Preview</h6>
                <div class="table-responsive">
                  <table class="table table-sm table-bordered">
                    <thead id="excelPreviewHeader"></thead>
                    <tbody id="excelPreviewBody"></tbody>
                  </table>
                </div>
                <p class="text-muted"><small>Showing preview of first 5 rows</small></p>
              </div>
              
              <div class="mb-3">
                <label for="excelDefaultImageUrl" class="form-label">Default Image URL (for keywords without image)</label>
                <input type="url" class="form-control" id="excelDefaultImageUrl" name="excelDefaultImageUrl" placeholder="https://example.com/image.jpg">
              </div>
            </div>
            
            <!-- PinClicks Analysis Tab - Enhanced with Excel Upload -->
            <div class="tab-pane fade" id="pinclicks" role="tabpanel" aria-labelledby="pinclicks-tab">
              <div class="alert alert-info">
                <strong>PinClicks Analysis</strong>
                <p>Upload a CSV or Excel file with PinClicks data. The system will analyze the file to extract relevant interests and can process multiple keywords at once.</p>
              </div>
              
              <!-- File Upload Tabs -->
              <ul class="nav nav-pills mb-3" id="pinclicksUploadTabs" role="tablist">
                <li class="nav-item" role="presentation">
                  <button class="nav-link active" id="pinclicks-csv-tab" data-bs-toggle="pill" data-bs-target="#pinclicks-csv" type="button" role="tab">CSV Upload</button>
                </li>
                <li class="nav-item" role="presentation">
                  <button class="nav-link" id="pinclicks-excel-tab" data-bs-toggle="pill" data-bs-target="#pinclicks-excel" type="button" role="tab">Excel Upload</button>
                </li>
              </ul>
              
              <div class="tab-content" id="pinclicksUploadTabsContent">
                <!-- CSV Upload Tab -->
                <div class="tab-pane fade show active" id="pinclicks-csv" role="tabpanel">
                  <div class="mb-3">
                    <label for="pinclicksFile" class="form-label">Upload PinClicks CSV File</label>
                    <input type="file" class="form-control" id="pinclicksFile" name="pinclicksFile" accept=".csv">
                    <div class="form-text">CSV file should have keywords in the first column and occurrence counts in the second column.</div>
                  </div>
                  
                  <div class="mb-3">
                    <label for="pinclicksRecipeInput" class="form-label">Recipe Input</label>
                    <textarea class="form-control" id="pinclicksRecipeInput" name="pinclicksRecipeInput" rows="8" placeholder="Enter either:
1. Simple keyword: Chocolate Chip Cookies
2. Complete recipe with ingredients and instructions:
Easy Chocolate Chip Cookies
Ingredients:
- 2 cups flour
- 1 cup sugar
- 1/2 cup butter
- 2 eggs
- 1 tsp vanilla
Instructions:
1. Preheat oven to 350°F
2. Mix dry ingredients
3. Add wet ingredients
4. Bake for 12 minutes"></textarea>
                    <div class="form-text">
                      <strong>💡 How it works:</strong>
                      <ul class="mb-0">
                        <li><strong>Simple keywords:</strong> "Chocolate Chip Cookies" → AI will generate the full recipe</li>
                        <li><strong>Complete recipes:</strong> Full recipe with ingredients and instructions → Stored as-is</li>
                      </ul>
                      The system automatically detects whether you entered a simple keyword or complete recipe!
                    </div>
                  </div>
                </div>
                
                <!-- Excel Upload Tab -->
                <div class="tab-pane fade" id="pinclicks-excel" role="tabpanel">
                  <div class="mb-3">
                    <label for="pinclicksExcelFile" class="form-label">Upload PinClicks Excel File</label>
                    <input type="file" class="form-control" id="pinclicksExcelFile" name="pinclicksExcelFile" accept=".xlsx, .xls, .csv">
                    <div class="form-text">
                      Excel file should have columns with these headers:
                      <ul class="mt-2">
                        <li><strong>Keyword</strong> (required) - The main keyword/recipe name</li>
                        <li><strong>Interests</strong> or <strong>Keywords</strong> (required) - Comma-separated list of related interests/keywords</li>
                        <li><strong>Category</strong> (optional) - Recipe category</li>
                        <li><strong>ImageUrl</strong> (optional) - Reference image URL</li>
                      </ul>
                      <div class="alert alert-info mt-2">
                        <strong>💡 How it works:</strong>
                        <ul class="mb-0">
                          <li><strong>Batch Processing:</strong> Upload multiple keywords with their interests in one file</li>
                          <li><strong>Smart Detection:</strong> System will automatically detect the best column mappings</li>
                        </ul>
                      </div>
                    </div>
                  </div>
                  
                  <div id="pinclicksExcelPreview" class="mb-3 d-none">
                    <h6>Excel Preview</h6>
                    <div class="table-responsive">
                      <table class="table table-sm table-bordered">
                        <thead id="pinclicksExcelPreviewHeader"></thead>
                        <tbody id="pinclicksExcelPreviewBody"></tbody>
                      </table>
                    </div>
                    <p class="text-muted"><small>Showing preview of first 5 rows</small></p>
                  </div>
                </div>
              </div>
              
              <!-- Common Fields -->
              <div class="mb-3">
                <label for="pinclicksCategory" class="form-label">Default Category</label>
                <select class="form-select" id="pinclicksCategory" name="pinclicksCategory">
                  <option value="">No category</option>
                  <option value="Breakfast">Breakfast</option>
                  <option value="Lunch">Lunch</option>
                  <option value="Dinner">Dinner</option>
                  <option value="Dessert">Dessert</option>
                  <option value="Appetizers">Appetizers</option>
                  <option value="Soups">Soups</option>
                  <option value="Salads">Salads</option>
                  <option value="Vegan">Vegan</option>
                  <option value="Vegetarian">Vegetarian</option>
                  <option value="Gluten-Free">Gluten-Free</option>
                  <option value="Low-Carb">Low-Carb</option>
                  <option value="Keto">Keto</option>
                  <option value="Paleo">Paleo</option>
                  <option value="Quick & Easy">Quick & Easy</option>
                  <option value="Budget-Friendly">Budget-Friendly</option>
                </select>
              </div>
              
              <div class="mb-3">
                <label for="pinclicksImageUrl" class="form-label">Default Reference Image URL</label>
                <input type="url" class="form-control" id="pinclicksImageUrl" name="pinclicksImageUrl" placeholder="https://example.com/image.jpg">
              </div>
              
              <div id="pinclicksAnalysisResult" class="mb-3 d-none">
                <div class="card">
                  <div class="card-header">
                    <h6 class="mb-0">Analysis Results</h6>
                  </div>
                  <div class="card-body">
                    <div id="pinclicksResultsContainer">
                      <!-- Results will be displayed here -->
                    </div>
                  </div>
                </div>
              </div>
              
              <button type="button" id="analyzePinclicksBtn" class="btn btn-secondary mb-3">Analyze File</button>
              <button type="button" id="addFromPinclicksBtn" class="btn btn-primary mb-3 d-none">Add Keywords with Interests</button>
            </div>
          </div>
          
          <div class="mb-3">
            <label for="defaultCategory" class="form-label">Default Category (for keywords without category)</label>
            <select class="form-select" id="defaultCategory" name="defaultCategory">
              <option value="">No category</option>
              <option value="Breakfast">Breakfast</option>
              <option value="Lunch">Lunch</option>
              <option value="Dinner">Dinner</option>
              <option value="Dessert">Dessert</option>
              <option value="Appetizers">Appetizers</option>
              <option value="Soups">Soups</option>
              <option value="Salads">Salads</option>
              <option value="Vegan">Vegan</option>
              <option value="Vegetarian">Vegetarian</option>
              <option value="Gluten-Free">Gluten-Free</option>
              <option value="Low-Carb">Low-Carb</option>
              <option value="Keto">Keto</option>
              <option value="Paleo">Paleo</option>
              <option value="Quick & Easy">Quick & Easy</option>
              <option value="Budget-Friendly">Budget-Friendly</option>
            </select>
          </div>
          
          <div class="mb-3">
            <label for="defaultInterests" class="form-label">Default Interests (for keywords without interests)</label>
            <input type="text" class="form-control" id="defaultInterests" name="defaultInterests" value="healthy eating, easy recipes, home cooking">
          </div>
          
          <button type="submit" id="addBtn" class="btn btn-primary">Add Keywords</button>
        </form>
      </div>
    </div>
  </div>
  
  <!-- Keywords List Section -->
  <div class="col-md-7">
    <div class="card">
      <div class="card-header">
        <div class="d-flex justify-content-between align-items-center">
          <h5 class="card-title mb-0">Keywords List</h5>
          <div>
            <button id="deleteSelectedBtn" class="btn btn-sm btn-danger me-2" disabled>Delete Selected</button>
            <!-- Crop Images Button -->
            <button id="cropImagesBtn" class="btn btn-primary" >
              Crop Selected Images
            </button>
            <button id="refreshBtn" class="btn btn-sm btn-secondary">
              <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
          </div>
        </div>
      </div>
      <div class="card-body">
        <!-- Search and Filter -->
        <div class="row mb-3">
          <div class="col-md-6">
            <form id="searchForm" class="d-flex">
              <input type="text" class="form-control me-2" id="searchInput" name="search" placeholder="Search keywords..." value="<%= search || '' %>">
              <button type="submit" class="btn btn-primary">
                <i class="bi bi-search"></i>
              </button>
            </form>
          </div>
          <div class="col-md-6">
            <select id="statusFilter" class="form-select">
              <option value="" <%= !status ? 'selected' : '' %>>All Keywords</option>
              <option value="pending" <%= status === 'pending' ? 'selected' : '' %>>Pending</option>
              <option value="processed" <%= status === 'processed' ? 'selected' : '' %>>Processed</option>
              <option value="failed" <%= status === 'failed' ? 'selected' : '' %>>Failed</option>
            </select>
          </div>
        </div>

        <!-- Select All Checkbox Row -->
        <% if (keywords && keywords.length > 0) { %>
          <div class="row mb-3">
            <div class="col-12">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="selectAllCheckbox" style="transform: scale(1.2);">
                <label class="form-check-label fw-bold" for="selectAllCheckbox">
                  Select All Keywords
                </label>
                <span class="ms-3 text-muted" id="selectionCounter">0 selected</span>
              </div>
            </div>
          </div>
        <% } %>

        <div id="statusMessage"></div>
        <div id="processingProgress" class="d-none">
          <!-- Workflow-Based Progress Display -->
          <div class="card mb-3">
            <div class="card-header bg-light">
              <div class="row align-items-center">
                <div class="col">
                  <h6 class="mb-0 text-primary">
                    <i class="fas fa-cog fa-spin me-2"></i>
                    Content Generation Pipeline
                  </h6>
                </div>
                <div class="col-auto">
                  <span class="badge bg-info me-2" id="progressCount">0 / 0</span>
                  <button type="button" class="btn btn-sm btn-outline-danger" id="stopProcessingBtn">
                    <i class="fas fa-stop me-1"></i>Stop
                  </button>
                </div>
              </div>
            </div>
            <div class="card-body">
              <!-- Main Progress Bar -->
              <div class="progress mb-4" style="height: 20px;">
                <div class="progress-bar progress-bar-striped progress-bar-animated" 
                     role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                  <span class="fw-bold" id="progressPercentage">0%</span>
                </div>
              </div>
              
              <!-- Workflow Steps -->
              <div class="row text-center mb-3">
                <div class="col">
                  <div class="workflow-step" id="step-recipe">
                    <div class="step-icon">🍽️</div>
                    <div class="step-label">Recipe Generation</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-facebook">
                    <div class="step-icon">📘</div>
                    <div class="step-label">Facebook Content</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-midjourney">
                    <div class="step-icon">🎨</div>
                    <div class="step-label">AI Image Prompt</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-discord">
                    <div class="step-icon">💬</div>
                    <div class="step-label">Discord Processing</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-pinterest">
                    <div class="step-icon">📌</div>
                    <div class="step-label">Pinterest Content</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
                <div class="col">
                  <div class="workflow-step" id="step-blog">
                    <div class="step-icon">📝</div>
                    <div class="step-label">Blog Post</div>
                    <div class="step-status">Pending</div>
                  </div>
                </div>
              </div>
              
              <!-- Summary Stats -->
              <div class="row text-center mb-3">
                <div class="col-3">
                  <span class="text-success fw-bold" id="successCount">0</span>
                  <small class="text-muted d-block">Completed</small>
                </div>
                <div class="col-3">
                  <span class="text-danger fw-bold" id="failedCount">0</span>
                  <small class="text-muted d-block">Failed</small>
                </div>
                <div class="col-3">
                  <span class="text-info fw-bold" id="remainingCount">0</span>
                  <small class="text-muted d-block">Remaining</small>
                </div>
                <div class="col-3">
                  <span class="fw-bold" id="elapsedTime">00:00</span>
                  <small class="text-muted d-block">Elapsed</small>
                </div>
              </div>
              
              <!-- Current Status -->
              <div class="bg-light rounded p-3 text-center">
                <p class="mb-0 fw-medium" id="progressText">Starting content generation...</p>
                <small class="text-muted" id="currentKeyword"></small>
              </div>
            </div>
          </div>
        </div>

        <!-- Keywords List Layout -->
        <% if (keywords && keywords.length > 0) { %>
          <div class="keywords-vertical-list">
            <% keywords.forEach(function(keyword, index) { %>
              <div class="keyword-card mb-3 border rounded p-3" data-id="<%= keyword.id %>" data-status="<%= keyword.status %>">
                <div class="row align-items-center">
                  <!-- Selection Checkbox -->
                  <div class="col-auto pe-3">
                    <div class="form-check">
                      <input class="form-check-input keyword-checkbox" type="checkbox" value="<%= keyword.id %>" 
                             id="keyword_<%= keyword.id %>" style="transform: scale(1.3); margin-top: 2px;"
                             <%= keyword.status === 'processed' ? 'disabled' : '' %>>
                      <label class="form-check-label visually-hidden" for="keyword_<%= keyword.id %>">
                        Select <%= keyword.keyword %>
                      </label>
                    </div>
                  </div>
                  
                  <!-- Number -->
                  <div class="col-auto pe-3">
                    <div class="keyword-number bg-primary text-white rounded-circle d-flex align-items-center justify-content-center" 
                         style="width: 35px; height: 35px; font-size: 14px; font-weight: bold;">
                      <%= index + 1 %>
                    </div>
                  </div>
                  
                  <!-- Image -->
<div class="col-auto pe-3">
  <% if (keyword.image_url) { %>
    <% 
      // Handle different types of image URLs
      let imageUrl = keyword.image_url;
      
      // Check if it's a base64 data URL (from cropped images)
      if (imageUrl.startsWith('data:image/')) {
        // Use the data URL directly - no processing needed
        // Data URLs are complete and self-contained
      }
      // Check if it's already a complete HTTP URL
      else if (imageUrl.startsWith('http')) {
        // Use as-is
      }
      // Handle relative/local file paths
      else {
        // If it's a relative path, ensure it starts with /
        if (!imageUrl.startsWith('/')) {
          imageUrl = '/' + imageUrl;
        }
        // If it's meant to be in recipe_images but doesn't have the path
        if (!imageUrl.includes('recipe_images')) {
          imageUrl = '/recipe_images/' + imageUrl.split('/').pop();
        }
      }
    %>
    <img src="<%= imageUrl %>" alt="<%= keyword.keyword %>" 
         class="keyword-image rounded border" style="width: 80px; height: 80px; object-fit: cover;"
         onerror="console.error('Image load error for keyword <%= keyword.id %>:', this.src.substring(0, 50) + '...'); this.onerror=null; this.src='/images/placeholder.png';"
         onload="console.log('✅ Image loaded successfully for keyword <%= keyword.id %>', this.src.startsWith('data:') ? 'data URL (' + Math.round(this.src.length/1024) + 'KB)' : this.src);">
  <% } else { %>
    <div class="keyword-image-placeholder bg-light border rounded d-flex align-items-center justify-content-center" 
         style="width: 80px; height: 80px; color: #6c757d;">
      <i class="bi bi-image" style="font-size: 24px;"></i>
    </div>
  <% } %>
</div>
                  
                  <!-- Keyword Details -->
                  <div class="col">
                    <h6 class="keyword-title mb-2"><%= keyword.keyword %></h6>
                   <div class="keyword-meta mb-2">
  <% if (keyword.category) { %>
    <span class="badge bg-secondary me-2"><%= keyword.category %></span>
  <% } %>
  
  <!-- Recipe Type Badge -->
  <% if (keyword.full_recipe && keyword.full_recipe.trim()) { %>
    <span class="badge bg-info me-2">📝 FULL RECIPE</span>
  <% } else { %>
    <span class="badge bg-warning me-2">🤖 AI RECIPE</span>
  <% } %>
  
  <!-- NEW SIMPLE BADGE SYSTEM -->
  <!-- Content Status Badge -->
  <% if (keyword.status === 'pending') { %>
    <span class="badge bg-warning me-2" data-badge="content">📝 PENDING</span>
  <% } else if (keyword.status === 'processing') { %>
    <span class="badge bg-info me-2" data-badge="content">🔄 PROCESSING</span>
  <% } else if (keyword.status === 'processed') { %>
    <span class="badge bg-success me-2" data-badge="content">✅ COMPLETED</span>
  <% } else if (keyword.status === 'failed') { %>
    <span class="badge bg-danger me-2" data-badge="content">❌ FAILED</span>
  <% } %>
  
  <!-- Image Status Badge -->
  <% if (keyword.status === 'processed' && keyword.recipe_id) { %>
    <span class="badge bg-secondary me-2 image-status-badge" data-badge="image" data-recipe-id="<%= keyword.recipe_id %>">🖼️ CHECKING...</span>
  <% } else { %>
    <span class="badge bg-info text-white me-2" data-badge="image">➖ NO IMAGE</span>
  <% } %>
</div>
                    
                    <% if (keyword.interests) { %>
                      <small class="text-muted d-block mb-1" title="<%= keyword.interests %>">
                        <i class="bi bi-tags me-1"></i> 
                        <%= keyword.interests.length > 50 ? keyword.interests.substring(0, 47) + '...' : keyword.interests %>
                      </small>
                    <% } %>
                    
                    <small class="text-muted d-block">
                      <i class="bi bi-clock me-1"></i> <%= new Date(keyword.added_at).toLocaleString() %>
                      <% if (keyword.owner_name) { %>
                        | <i class="bi bi-person me-1"></i> <%= keyword.owner_name %>
                      <% } %>
                    </small>
                  </div>
                  
                  <!-- Actions -->
                  <div class="col-auto">
                    <div class="btn-group-vertical btn-group-sm">
                      <% if (keyword.status === 'processed' && keyword.recipe_id) { %>
                        <a href="/recipe/<%= keyword.recipe_id %>" class="btn btn-sm btn-primary mb-1">
                          <i class="bi bi-eye"></i> View
                        </a>
                        <button type="button" class="btn btn-sm btn-info regenerate-image-btn mb-1" data-recipe-id="<%= keyword.recipe_id %>">
                          <i class="bi bi-arrow-repeat"></i> Regenerate
                        </button>
                      <% } else if (keyword.status === 'pending') { %>
                        <button type="button" class="btn btn-sm btn-success process-btn mb-1" data-id="<%= keyword.id %>">
                          <i class="bi bi-play"></i> Process
                        </button>
                      <% } else if (keyword.status === 'failed') { %>
                        <button type="button" class="btn btn-sm btn-warning retry-btn mb-1" data-id="<%= keyword.id %>">
                          <i class="bi bi-arrow-clockwise"></i> Retry
                        </button>
                      <% } %>
                      
                      <% if (keyword.status !== 'processed') { %>
                        <button type="button" class="btn btn-sm btn-danger delete-btn" data-id="<%= keyword.id %>">
                          <i class="bi bi-trash"></i> Delete
                        </button>
                      <% } %>
                    </div>
                  </div>
                </div>
              </div>
            <% }); %>
          </div>
          
          <!-- Pagination -->
          <% if (totalPages > 1) { %>
            <nav aria-label="Keywords pagination">
              <ul class="pagination justify-content-center">
                <% if (currentPage > 1) { %>
                  <li class="page-item">
                    <a class="page-link" href="/keywords?page=<%= currentPage - 1 %><%= status ? '&status=' + status : '' %><%= search ? '&search=' + search : '' %>">Previous</a>
                  </li>
                <% } else { %>
                  <li class="page-item disabled">
                    <span class="page-link">Previous</span>
                  </li>
                <% } %>
                
                <% for (let i = 1; i <= totalPages; i++) { %>
                  <% if (i === currentPage) { %>
                    <li class="page-item active">
                      <span class="page-link"><%= i %></span>
                    </li>
                  <% } else if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) { %>
                    <li class="page-item">
                      <a class="page-link" href="/keywords?page=<%= i %><%= status ? '&status=' + status : '' %><%= search ? '&search=' + search : '' %>"><%= i %></a>
                    </li>
                  <% } else if (i === currentPage - 3 || i === currentPage + 3) { %>
                    <li class="page-item disabled">
                      <span class="page-link">...</span>
                    </li>
                  <% } %>
                <% } %>
                
                <% if (currentPage < totalPages) { %>
                  <li class="page-item">
                    <a class="page-link" href="/keywords?page=<%= currentPage + 1 %><%= status ? '&status=' + status : '' %><%= search ? '&search=' + search : '' %>">Next</a>
                  </li>
                <% } else { %>
                  <li class="page-item disabled">
                    <span class="page-link">Next</span>
                  </li>
                <% } %>
              </ul>
            </nav>
          <% } %>
        <% } else { %>
          <div class="alert alert-info">
            No keywords found. Add some keywords to get started.
          </div>
        <% } %>
      </div>
    </div>
  </div>
</div>

<!-- Simple Crop Modal -->
<div class="modal fade" id="cropModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Crop Image</h5>

        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div id="cropContainer">
          <!-- Cropper will be inserted here dynamically -->
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-success" id="saveCroppedImages">
          <i class="bi bi-check2"></i> Save Cropped Images
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Other Modals (kept as-is) -->
<!-- Process Result Modal -->
<div class="modal fade" id="processResultModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Processing Results</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="table-responsive">
          <table class="table table-hover" id="resultTable">
            <thead>
              <tr>
                <th>Keyword</th>
                <th>Status</th>
                <th>Message</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="resultTableBody"></tbody>
          </table>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Confirmation Modal -->
<div class="modal fade" id="confirmModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Confirmation</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p id="confirmMessage">Are you sure you want to perform this action?</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-danger" id="confirmButton">Confirm</button>
      </div>
    </div>
  </div>
</div>

<!-- Prompt Edit Modal -->
<div class="modal fade" id="promptEditModal" tabindex="-1" aria-labelledby="promptEditModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="promptEditModalLabel">Edit Midjourney Prompt</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="promptEditAlert" class="alert alert-danger d-none">
          <p><strong>Safety check failed!</strong> Your prompt contains potentially blocked terms:</p>
          <p id="promptEditBlockedTerms"></p>
          <p>Please modify these terms to avoid being blocked by Midjourney's safety filter.</p>
        </div>
        
        <form id="promptEditForm">
          <input type="hidden" id="promptEditRecipeId" name="recipeId">
          
          <div class="mb-3">
            <label for="promptEditText" class="form-label">Midjourney Prompt:</label>
            <textarea class="form-control" id="promptEditText" name="prompt" rows="6" required></textarea>
            <div class="form-text">
              Edit this prompt to avoid terms that might trigger Midjourney's safety filter.
              <br>Common issues: terms like "skillet" (contains "kill"), "skillful", etc.
            </div>
          </div>
          
          <div class="mb-3">
            <label class="form-label">Troubleshooting Tips:</label>
            <ul class="small">
              <li>Replace "skillet" with "pan" or "cooking pan"</li>
              <li>Replace problematic words with synonyms</li>
              <li>If specific ingredients are causing issues, try rewording them</li>
            </ul>
          </div>
        </form>
        
        <div id="promptEditSpinner" class="text-center d-none">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2">Generating image with edited prompt...</p>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="promptEditSaveBtn">Generate Image</button>
      </div>
    </div>
  </div>
</div>


<!-- Include Scripts -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
<link rel="stylesheet" href="/css/image-cropper.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
<script src="/js/image-cropper.js"></script>

<style>
/* Custom styles for vertical keyword layout */
.keyword-card {
  transition: all 0.2s ease;
  background: #1E243C;
}

.keyword-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  transform: translateY(-2px);
}

.keyword-image {
  border: 2px solid #e9ecef;
}

.keyword-image-placeholder {
  border: 2px dashed #e9ecef;
}

.keyword-title {
  font-weight: 600;
  color: white;
}

.keyword-meta .badge {
  font-size: 0.75rem;
}

.keyword-number {
  font-family: 'Arial', sans-serif;
}
</style>

<script>
// Page-specific JavaScript for Keywords Management
document.addEventListener('DOMContentLoaded', function() {
  // Excel file handling variables
  let parsedExcelData = null;
  
  // Enhanced PinClicks Analysis with Excel Support
  let parsedPinclicksData = null;
  let analyzedPinclicksResults = null;
  
  
  // Helper to safely add click handlers
  function safeAddClickHandler(elementId, handler) {
    const element = document.getElementById(elementId);
    if (element) {
      console.log(`✅ Found element ${elementId}, adding click handler`);
      element.onclick = handler;
      
      // Debug: Test the handler immediately
      console.log(`🔍 Testing click handler for ${elementId}:`, typeof handler);
    } else {
      console.warn(`⚠️ Element ${elementId} not found, cannot add click handler`);
    }
  }

  // Get current active tab
  function getCurrentActiveTab() {
    const manualTab = document.getElementById('manual-tab');
    const excelTab = document.getElementById('excel-tab');
    const pinclicksTab = document.getElementById('pinclicks-tab');
    
    if (manualTab && manualTab.classList.contains('active')) return 'manual-tab';
    if (excelTab && excelTab.classList.contains('active')) return 'excel-tab';
    if (pinclicksTab && pinclicksTab.classList.contains('active')) return 'pinclicks-tab';
    
    return 'manual-tab';
  }

  // Get selected template settings (currently defaults to no template)
  function getSelectedTemplate() {
    return {
      useTemplate: false,
      templateId: null
    };
  }

  // ENHANCED: Image status checking with comprehensive debugging
  function debugImageStatusSetup() {
    console.log('=== IMAGE STATUS DEBUG REPORT ===');
    
    const allCells = document.querySelectorAll('.image-status-cell');
    const cellsWithRecipeId = document.querySelectorAll('.image-status-cell[data-recipe-id]');
    
    console.log(`Total image status cells: ${allCells.length}`);
    console.log(`Cells with recipe ID: ${cellsWithRecipeId.length}`);
    
    allCells.forEach((cell, index) => {
      const recipeId = cell.getAttribute('data-recipe-id');
      const currentContent = cell.innerHTML.trim();
      
      console.log(`Cell ${index + 1}:`, {
        hasRecipeId: !!recipeId,
        recipeId: recipeId,
        isEmpty: !recipeId || recipeId === 'null' || recipeId === 'undefined' || recipeId === '',
        currentContent: currentContent.substring(0, 50) + '...'
      });
    });
    
    console.log('=== END DEBUG REPORT ===');
  }

  // ENHANCED: Image status checking function
  // SMART IMAGE MONITORING - No more failed status bugs!
  function startSmartImageMonitoring(recipeId, keywordId) {
    console.log(`🖼️ Starting fast monitoring for recipe ${recipeId}, keyword ${keywordId}`);
    
    let attempts = 0;
    const maxAttempts = 30;
    let currentTimeout;
    
    // IMMEDIATE CHECK: Check right away for existing images
    checkImageStatus();
    
    async function checkImageStatus() {
      attempts++;
      console.log(`🖼️ Image check attempt ${attempts}/${maxAttempts} for recipe ${recipeId}`);
      
      // Check if keyword was cancelled before continuing image monitoring
      const keywordCard = document.querySelector(`.keyword-card[data-id="${keywordId}"]`);
      if (keywordCard) {
        const currentStatus = keywordCard.getAttribute('data-status');
        if (currentStatus === 'failed') {
          console.log(`🛑 Image monitoring stopped - keyword ${keywordId} was cancelled`);
          updateImageBadge(keywordId, 'cancelled');
          return;
        }
      }
      
      try {
        const response = await fetch(`/midjourney/api/recipe/${recipeId}`, {
          method: 'GET',
          headers: { 'Cache-Control': 'no-cache' }
        });
        
        if (!response.ok) {
          console.log(`🖼️ API not ready yet for recipe ${recipeId} (attempt ${attempts})`);
          
          if (attempts >= maxAttempts) {
            updateImageBadge(keywordId, 'timeout');
            return;
          }
          scheduleNext();
          return;
        }
        
        const data = await response.json();
        
        if (data.success && data.images && data.images.length > 0) {
          const latestImage = data.images[0];
          console.log(`🖼️ Image status for recipe ${recipeId}:`, latestImage.status);
          
          switch (latestImage.status) {
            case 'completed':
            case 'success':
            case 'done':
              updateImageBadge(keywordId, 'generated');
              return; // Stop monitoring - found completed image
            case 'failed':
              updateImageBadge(keywordId, 'failed');
              return; // Stop monitoring - failed
            case 'pending':
            case 'processing':
            case 'in_progress':
            case 'queued':
              updateImageBadge(keywordId, 'generating');
              break;
            default:
              console.log(`🖼️ Unknown image status: ${latestImage.status}`);
              updateImageBadge(keywordId, 'generating');
          }
        } else {
          console.log(`🖼️ No images yet for recipe ${recipeId}, continuing to monitor...`);
          updateImageBadge(keywordId, 'generating');
        }
        
        // Continue checking unless max attempts reached
        if (attempts >= maxAttempts) {
          updateImageBadge(keywordId, 'timeout');
          return;
        }
        
        scheduleNext();
        
      } catch (error) {
        console.log(`🖼️ Error checking recipe ${recipeId} (attempt ${attempts}):`, error.message);
        
        if (attempts >= maxAttempts) {
          updateImageBadge(keywordId, 'error');
          return;
        }
        
        scheduleNext();
      }
    }
    
    function scheduleNext() {
      // SMART INTERVALS: Fast initially, then slower
      let interval;
      if (attempts <= 3) {
        interval = 2000; // First 3 checks every 2 seconds (for existing images)
      } else if (attempts <= 10) {
        interval = 10000; // Next 7 checks every 10 seconds
      } else {
        interval = 30000; // After that, every 30 seconds
      }
      
      currentTimeout = setTimeout(checkImageStatus, interval);
    }
  }
  
  // ASYNC PROCESSING: Poll keyword status instead of waiting for response  
  function startKeywordStatusPolling(keywordId) {
    console.log(`📡 Starting status polling for keyword: ${keywordId}`);
    
    let attempts = 0;
    const maxAttempts = 60; // Poll for up to 10 minutes (60 * 10s)
    
    const pollInterval = setInterval(async () => {
      attempts++;
      console.log(`📡 Status poll attempt ${attempts}/${maxAttempts} for keyword ${keywordId}`);
      
      try {
        const response = await fetch(`/api/keywords/status/${keywordId}`, {
          method: 'GET',
          headers: { 'Cache-Control': 'no-cache' }
        });
        
        if (!response.ok) {
          console.log(`📡 Status API not ready yet (attempt ${attempts})`);
          
          // If we've tried many times and still getting errors, give up
          if (attempts >= maxAttempts) {
            clearInterval(pollInterval);
            updateKeywordRowInUI(keywordId, { status: 'failed', message: 'Polling timeout' });
            showStatus('error', 'Processing status check timed out');
          }
          return;
        }
        
        const data = await response.json();
        console.log(`📡 Keyword status update:`, data);
        
        if (data.status === 'processed') {
          clearInterval(pollInterval);
          updateKeywordRowInUI(keywordId, data);
          showStatus('success', 'Keyword processed successfully!');
          
          // Start image monitoring
          if (data.recipeId) {
            setTimeout(() => startSmartImageMonitoring(data.recipeId, keywordId), 10000);
          }
          
        } else if (data.status === 'failed') {
          clearInterval(pollInterval);
          updateKeywordRowInUI(keywordId, data);
          showStatus('error', 'Processing failed: ' + (data.message || 'Unknown error'));
          
        } else if (data.status === 'processing') {
          // Still processing, continue polling and update workflow
          console.log(`📡 Still processing... (${data.processingTime || 'unknown'} elapsed)`);
          
          // Update workflow based on real status
          updateWorkflowBasedOnStatus(keywordId, 'processing', data);
          
        } else {
          console.log(`📡 Unexpected status: ${data.status}`);
        }
        
        // Stop after max attempts to avoid infinite polling
        if (attempts >= maxAttempts) {
          clearInterval(pollInterval);
          showStatus('warning', 'Processing is taking longer than expected. Please refresh to check status.');
        }
        
      } catch (error) {
        console.log(`📡 Error polling status (attempt ${attempts}):`, error.message);
        
        // Stop on too many errors
        if (attempts >= maxAttempts) {
          clearInterval(pollInterval);
          showStatus('error', 'Unable to check processing status. Please refresh the page.');
        }
      }
    }, 10000); // Poll every 10 seconds
  }

  // Helper function to update image badge without affecting content status
  function updateImageBadge(keywordId, status) {
    const card = document.querySelector(`.keyword-card[data-id="${keywordId}"]`);
    if (!card) return;
    
    const imageBadge = card.querySelector('[data-badge="image"]');
    if (!imageBadge) return;
    
    switch (status) {
      case 'generated':
        imageBadge.className = 'badge bg-success me-2';
        imageBadge.textContent = '🖼️ GENERATED';
        break;
      case 'generating':
        imageBadge.className = 'badge bg-warning me-2';
        imageBadge.textContent = '🖼️ GENERATING';
        break;
      case 'failed':
        imageBadge.className = 'badge bg-danger me-2';
        imageBadge.textContent = '🖼️ FAILED';
        break;
      case 'timeout':
        imageBadge.className = 'badge bg-secondary me-2';
        imageBadge.textContent = '🖼️ CHECK RECIPE';
        break;
      case 'error':
        imageBadge.className = 'badge bg-warning me-2';
        imageBadge.textContent = '🖼️ CHECK RECIPE';
        break;
      case 'cancelled':
        imageBadge.className = 'badge bg-secondary me-2';
        imageBadge.textContent = '🖼️ CANCELLED';
        break;
    }
    
    console.log(`🖼️ Updated image badge for keyword ${keywordId}: ${status}`);
  }

  // OLD IMAGE STATUS CHECK (kept for compatibility)
  async function checkImageStatus() {
    const imageBadges = document.querySelectorAll('.image-status-badge[data-recipe-id]');
    
    console.log(`🖼️ Checking image status for ${imageBadges.length} recipes`);
    
    imageStatusCells.forEach(async (cell, index) => {
      const recipeId = cell.getAttribute('data-recipe-id');
      
      console.log(`Cell ${index + 1}: Recipe ID = "${recipeId}"`);
      
      // Enhanced validation
      if (!recipeId || recipeId === 'null' || recipeId === 'undefined' || recipeId.trim() === '' || recipeId === 'null') {
        console.warn(`Cell ${index + 1}: Invalid recipe ID, skipping`);
        cell.innerHTML = `<span class="badge bg-secondary">❓ No Recipe ID</span>`;
        return;
      }
      
      try {
        console.log(`Fetching status for recipe: ${recipeId}`);
        
        const response = await fetch(`/midjourney/api/recipe/${recipeId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          }
        });
        
        console.log(`Recipe ${recipeId}: Response status = ${response.status}, OK = ${response.ok}`);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`Recipe ${recipeId}: HTTP ${response.status} - ${errorText}`);
          
          if (response.status === 401) {
            cell.innerHTML = `<span class="badge bg-warning">🔐 Unauthorized</span>`;
          } else if (response.status === 403) {
            cell.innerHTML = `<span class="badge bg-warning">🚫 Forbidden</span>`;
          } else if (response.status === 404) {
            cell.innerHTML = `<span class="badge bg-secondary">❓ Not Found</span>`;
          } else {
            cell.innerHTML = `<span class="badge bg-danger">⚠️ HTTP ${response.status}</span>`;
          }
          return;
        }
        
        const responseText = await response.text();
        console.log(`Recipe ${recipeId}: Raw response length = ${responseText.length}`);
        console.log(`Recipe ${recipeId}: Response preview = ${responseText.substring(0, 200)}...`);
        
        let data;
        try {
          data = JSON.parse(responseText);
        } catch (parseError) {
          console.error(`Recipe ${recipeId}: Failed to parse JSON:`, parseError);
          console.error(`Recipe ${recipeId}: Raw response was:`, responseText);
          cell.innerHTML = `<span class="badge bg-danger">📄 Parse Error</span>`;
          return;
        }
        
        console.log(`Recipe ${recipeId}: Parsed data structure:`, {
          success: data.success,
          hasImages: !!(data.images && data.images.length > 0),
          imageCount: data.images ? data.images.length : 0,
          dataKeys: Object.keys(data)
        });
        
        if (data.success && data.images && Array.isArray(data.images) && data.images.length > 0) {
          const latestImage = data.images[0];
          console.log(`Recipe ${recipeId}: Latest image:`, {
            status: latestImage.status,
            id: latestImage.id,
            hasUrl: !!latestImage.image_url
          });
          
          // Handle all possible status values with emojis
          switch (latestImage.status) {
            case 'completed':
            case 'success':
            case 'done':
              cell.innerHTML = `<span class="badge bg-success">✅ Generated</span>`;
              break;
            case 'pending':
            case 'processing':
            case 'in_progress':
            case 'queued':
              cell.innerHTML = `<span class="badge bg-warning">⏳ Pending</span>`;
              break;
            case 'failed':
            case 'error':
              cell.innerHTML = `<span class="badge bg-danger">❌ Failed</span>`;
              break;
            default:
              cell.innerHTML = `<span class="badge bg-info">🔄 ${latestImage.status}</span>`;
          }
        } else if (data.success === false) {
          console.log(`Recipe ${recipeId}: API returned success=false:`, data.message || data.error);
          cell.innerHTML = `<span class="badge bg-secondary">⭕ No Images</span>`;
        } else {
          console.log(`Recipe ${recipeId}: No images in successful response`);
          cell.innerHTML = `<span class="badge bg-secondary">⭕ No Images</span>`;
        }
        
      } catch (error) {
        console.error(`Recipe ${recipeId}: Fetch error:`, {
          message: error.message,
          name: error.name,
          stack: error.stack
        });
        
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          cell.innerHTML = `<span class="badge bg-danger">🌐 Network Error</span>`;
        } else if (error.message.includes('JSON')) {
          cell.innerHTML = `<span class="badge bg-danger">📄 Parse Error</span>`;
        } else {
          cell.innerHTML = `<span class="badge bg-danger">⚠️ Error</span>`;
        }
      }
    });
  }

  // Smart monitoring with error backoff
  let imageStatusCheckInterval;
  let consecutiveErrors = 0;

  function startImageStatusMonitoring() {
    if (imageStatusCheckInterval) {
      clearInterval(imageStatusCheckInterval);
    }
    
    imageStatusCheckInterval = setInterval(async () => {
      try {
        await checkImageStatus();
        consecutiveErrors = 0;
      } catch (error) {
        consecutiveErrors++;
        console.error('Image status check failed:', error);
        
        if (consecutiveErrors >= 3) {
          clearInterval(imageStatusCheckInterval);
          console.warn('Too many errors, reducing check frequency');
          imageStatusCheckInterval = setInterval(checkImageStatus, 120000); // 2 minutes
        }
      }
    }, 30000); // 30 seconds
  }

  // Update selected count
  function updateSelectedCount() {
    const count = document.querySelectorAll('.keyword-checkbox:checked').length;
    const countElement = document.getElementById('selectedCount');
    const selectionCounter = document.getElementById('selectionCounter');
    
    if (countElement) {
      countElement.textContent = count;
    }
    
    if (selectionCounter) {
      selectionCounter.textContent = `${count} selected`;
    }
    
    const processBtn = document.getElementById('processSelectedBtn');
    if (processBtn) {
      processBtn.disabled = count === 0;
    }
    
    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    if (deleteSelectedBtn) {
      deleteSelectedBtn.disabled = count === 0;
    }
    
  }

  // Setup checkbox listeners
  document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
    checkbox.addEventListener('change', updateSelectedCount);
  });
  
  // Select All Checkbox
  const selectAllCheckbox = document.getElementById('selectAllCheckbox');
  if (selectAllCheckbox) {
    selectAllCheckbox.addEventListener('change', function() {
      const checkboxes = document.querySelectorAll('.keyword-checkbox:not(:disabled)');
      checkboxes.forEach(checkbox => {
        checkbox.checked = this.checked;
      });
      updateSelectedCount();
    });
  }
  
  // Status filter change
  const statusFilter = document.getElementById('statusFilter');
  if (statusFilter) {
    statusFilter.addEventListener('change', function() {
      window.location.href = '/keywords' + 
        (this.value ? '?status=' + this.value : '') + 
        (document.getElementById('searchInput')?.value ? 
          (this.value ? '&' : '?') + 'search=' + document.getElementById('searchInput').value : '');
    });
  }
  
  const refreshBtn = document.getElementById('refreshBtn');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', function() {
      const url = new URL(window.location);
      url.searchParams.set('_refresh', Date.now());
      window.location.href = url.toString();
    });
  }

  // Status message function
  function showStatus(type, message) {
    const statusElement = document.getElementById('statusMessage');
    if (!statusElement) return;
    
    let alertClass = 'alert-info';
    if (type === 'error') alertClass = 'alert-danger';
    if (type === 'success') alertClass = 'alert-success';
    if (type === 'warning') alertClass = 'alert-warning';
    
    statusElement.innerHTML = `
      <div class="alert ${alertClass} alert-dismissible fade show" role="alert">
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
      </div>
    `;
    
    statusElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  // Workflow step management
  function resetWorkflowSteps(contentOption = 'all') {
    const allSteps = ['recipe', 'facebook', 'midjourney', 'discord', 'pinterest', 'blog'];
    
    // Define which steps are needed for each content option
    const stepMapping = {
      'facebook': ['recipe', 'facebook', 'midjourney', 'discord'],
      'pinterest': ['recipe', 'pinterest', 'midjourney', 'discord'],
      'all': ['recipe', 'facebook', 'midjourney', 'discord', 'pinterest', 'blog']
    };
    
    const neededSteps = stepMapping[contentOption] || stepMapping['all'];
    
    // Hide all steps first
    allSteps.forEach(step => {
      const element = document.getElementById(`step-${step}`);
      if (element) {
        const col = element.closest('.col');
        if (neededSteps.includes(step)) {
          // Show and reset this step
          col.style.display = 'block';
          element.className = 'workflow-step pending';
          element.querySelector('.step-status').textContent = 'Pending';
        } else {
          // Hide this step
          col.style.display = 'none';
        }
      }
    });
  }
  
  function updateWorkflowStep(step, status, text = null) {
    const element = document.getElementById(`step-${step}`);
    if (element) {
      element.className = `workflow-step ${status}`;
      if (text) {
        element.querySelector('.step-status').textContent = text;
      } else {
        element.querySelector('.step-status').textContent = status.charAt(0).toUpperCase() + status.slice(1);
      }
    }
    
    // Update progress bar to follow workflow steps
    updateWorkflowProgressBar(step, status);
  }
  
  function updateWorkflowProgressBar(step, status) {
    // Define workflow step order and get visible steps
    const allSteps = ['recipe', 'facebook', 'midjourney', 'discord', 'pinterest', 'blog'];
    
    // Get only visible steps (not hidden by content options)
    const visibleSteps = allSteps.filter(stepId => {
      const stepElement = document.getElementById(`step-${stepId}`);
      return stepElement && stepElement.closest('.col').style.display !== 'none';
    });
    
    if (visibleSteps.length === 0) return;
    
    // Find current step index in visible steps
    const currentStepIndex = visibleSteps.indexOf(step);
    if (currentStepIndex === -1) return;
    
    // Calculate progress percentage
    let progressPercentage = 0;
    
    if (status === 'active') {
      // If step is active, progress is at the beginning of this step
      progressPercentage = (currentStepIndex / visibleSteps.length) * 100;
    } else if (status === 'completed') {
      // If step is completed, progress is at the end of this step
      progressPercentage = ((currentStepIndex + 1) / visibleSteps.length) * 100;
    } else if (status === 'failed') {
      // If step failed, keep progress at current step
      progressPercentage = (currentStepIndex / visibleSteps.length) * 100;
    }
    
    // Update progress bar
    const progressBar = document.querySelector('.progress-bar');
    const progressPercentageElement = document.getElementById('progressPercentage');
    
    if (progressBar && progressPercentageElement) {
      progressBar.style.width = `${progressPercentage}%`;
      progressBar.setAttribute('aria-valuenow', Math.round(progressPercentage));
      progressPercentageElement.textContent = `${Math.round(progressPercentage)}%`;
      
      // Add visual feedback based on status
      if (status === 'active') {
        progressBar.classList.add('progress-animated');
        progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--primary-purple) 0%, #8860e6 100%)';
      } else if (status === 'completed') {
        progressBar.classList.remove('progress-animated');
        progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--accent-teal) 0%, #4aecbf 100%)';
      } else if (status === 'failed') {
        progressBar.classList.remove('progress-animated');
        progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--danger-red) 0%, #ff6b63 100%)';
      }
    }
  }
  
  function showWorkflowProgress(step, keyword = '') {
    const stepNames = {
      'recipe': 'Generating recipe content',
      'facebook': 'Creating Facebook post',
      'midjourney': 'Generating AI image prompt',
      'discord': 'Processing in Discord',
      'pinterest': 'Creating Pinterest pins',
      'blog': 'Writing blog post'
    };
    
    updateWorkflowStep(step, 'active', 'Processing');
    document.getElementById('progressText').textContent = stepNames[step] || 'Processing...';
    if (keyword) {
      document.getElementById('currentKeyword').textContent = `Current: ${keyword}`;
    }
  }

  // Real workflow progression based on server status (global function)
  function updateWorkflowBasedOnStatus(keywordId, status, data) {
    const keywordElement = document.querySelector(`[data-id="${keywordId}"]`);
    const keywordText = keywordElement ? keywordElement.querySelector('.keyword-text')?.textContent || keywordId : keywordId;
    
    if (status === 'processing') {
      // Show content generation step based on processing time
      const processingTime = data && data.processingTime ? parseInt(data.processingTime) : 0;
      
      if (processingTime < 30) {
        showWorkflowProgress('recipe', `Generating recipe for: ${keywordText}`);
      } else if (processingTime < 60) {
        // Determine which content step based on contentOption
        const contentOption = localStorage.getItem('currentContentOption') || 'all';
        if (contentOption === 'facebook' || contentOption === 'all') {
          showWorkflowProgress('facebook', `Creating Facebook content for: ${keywordText}`);
        } else if (contentOption === 'pinterest') {
          showWorkflowProgress('pinterest', `Creating Pinterest content for: ${keywordText}`);
        }
      } else if (processingTime < 90) {
        showWorkflowProgress('midjourney', `Generating image prompt for: ${keywordText}`);
      } else {
        // Check if content is done but waiting for images
        showWorkflowProgress('discord', `Waiting for image generation: ${keywordText}`);
      }
    } else if (status === 'processed') {
      // Mark all visible steps as completed
      const visibleSteps = document.querySelectorAll('.workflow-step');
      visibleSteps.forEach(stepElement => {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'completed');
        }
      });
      document.getElementById('progressText').textContent = `✅ Completed: ${keywordText}`;
    } else if (status === 'failed') {
      // Mark first visible step as failed
      const visibleSteps = document.querySelectorAll('.workflow-step');
      for (const stepElement of visibleSteps) {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'failed');
          break;
        }
      }
      document.getElementById('progressText').textContent = `❌ Failed: ${keywordText}`;
    }
  }

  // Stop processing functionality
  async function stopProcessing() {
    console.log('🛑 Stop processing called');
    
    // Set global cancellation flag
    window.processingCancelled = true;
    console.log('🛑 Set global cancellation flag');
    
    // Get all currently processing keywords
    const processingKeywords = document.querySelectorAll('.keyword-card[data-status="processing"]');
    const keywordIds = Array.from(processingKeywords).map(card => card.getAttribute('data-id'));
    
    console.log(`🛑 Found ${keywordIds.length} keywords to cancel:`, keywordIds);
    
    // Update UI immediately for all processing keywords
    keywordIds.forEach(keywordId => {
      updateKeywordRowInUI(keywordId, { 
        status: 'failed', 
        message: 'Cancelled by user',
        processed_at: new Date().toISOString()
      });
    });
    
    // Try to cancel on server and debug what happens
    if (keywordIds.length > 0) {
      console.log('🔍 Calling normal cancel endpoint...');
      fetch('/api/keywords/cancel', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache'
        },
        body: JSON.stringify({ keywordIds })
      }).then(async response => {
        if (response.ok) {
          const data = await response.json();
          console.log('✅ Server cancellation successful:', data);
          
          // Now debug each keyword individually
          console.log('🔍 Starting individual keyword debugging...');
          for (const keywordId of keywordIds) {
            try {
              const debugResponse = await fetch(`/api/keywords/debug-force-cancel/${keywordId}`);
              if (debugResponse.ok) {
                const debugData = await debugResponse.json();
                console.log(`🔍 Debug data for keyword ${keywordId}:`, debugData);
              }
            } catch (debugError) {
              console.log(`⚠️ Debug failed for keyword ${keywordId}:`, debugError);
            }
          }
        } else {
          console.log('⚠️ Server cancellation failed, but UI already updated');
        }
      }).catch(error => {
        console.log('⚠️ Server cancellation error, but UI already updated:', error);
      });
    }
    
    // Stop all intervals
    if (window.processingTimeInterval) {
      clearInterval(window.processingTimeInterval);
      window.processingTimeInterval = null;
    }
    
    // Stop batch monitoring
    if (window.batchMonitoringInterval) {
      clearInterval(window.batchMonitoringInterval);
      window.batchMonitoringInterval = null;
    }
    
    // Clear localStorage
    localStorage.removeItem('currentContentOption');
    localStorage.removeItem('processingStartTime');
    
    // Update UI
    document.getElementById('progressText').textContent = `🛑 Processing cancelled - ${keywordIds.length} keywords stopped`;
    document.getElementById('currentKeyword').textContent = '';
    
    // Mark all workflow steps as stopped
    const visibleSteps = document.querySelectorAll('.workflow-step');
    visibleSteps.forEach(stepElement => {
      if (stepElement.closest('.col').style.display !== 'none') {
        const stepId = stepElement.id.replace('step-', '');
        updateWorkflowStep(stepId, 'failed');
      }
    });
    
    // Change progress bar to indicate stopped
    const progressBar = document.querySelector('.progress-bar');
    if (progressBar) {
      progressBar.classList.remove('progress-bar-animated');
      progressBar.style.backgroundImage = 'linear-gradient(90deg, #dc3545 0%, #f86a6a 100%)';
    }
    
    // Hide progress bar after a short delay
    setTimeout(() => {
      const progressElement = document.getElementById('processingProgress');
      if (progressElement) {
        progressElement.classList.add('d-none');
        showStatus('success', `✅ Processing cancelled successfully. ${keywordIds.length} keywords marked as cancelled.`);
      }
    }, 3000);
  }

  // Stop button event handler
  safeAddClickHandler('stopProcessingBtn', function() {
    console.log('🛑 Stop button clicked!');
    if (confirm('Are you sure you want to cancel the processing? This will mark all processing keywords as cancelled and they will not continue.')) {
      console.log('🛑 User confirmed cancellation, calling stopProcessing()');
      stopProcessing();
    } else {
      console.log('🛑 User cancelled the cancellation');
    }
  });

  // Process selected keywords
  const processSelectedButton = document.getElementById('processSelectedBtn');
  if (processSelectedButton) {
    console.log('✅ Found processSelectedBtn, adding click handler');
    processSelectedButton.addEventListener('click', function() {
    const selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
      .map(cb => cb.value);
    
    if (selectedKeywords.length === 0) {
      alert('No keywords selected for processing.');
      return;
    }
    
    const optionElement = document.querySelector('input[name="contentOption"]:checked');
    const contentOption = optionElement ? optionElement.value : 'facebook';
    
    if (confirm(`Process ${selectedKeywords.length} keywords with ${contentOption} option?`)) {
      const statusElement = document.getElementById('statusMessage');
      if (statusElement) {
        statusElement.innerHTML = '<div class="alert alert-info">Processing keywords, please wait...</div>';
      }
      
      const progressElement = document.getElementById('processingProgress');
      const progressBar = progressElement.querySelector('.progress-bar');
      const progressText = document.getElementById('progressText');
      
      // Initialize workflow progress
      progressElement.classList.remove('d-none');
      progressBar.style.width = '0%';
      progressBar.setAttribute('aria-valuenow', 0);
      progressText.textContent = 'Initializing content generation pipeline...';
      
      // Initialize simple counters
      document.getElementById('progressCount').textContent = `0 / ${selectedKeywords.length}`;
      document.getElementById('progressPercentage').textContent = '0%';
      document.getElementById('successCount').textContent = '0';
      document.getElementById('failedCount').textContent = '0';
      document.getElementById('remainingCount').textContent = selectedKeywords.length;
      document.getElementById('elapsedTime').textContent = '00:00';
      document.getElementById('currentKeyword').textContent = '';
      
      // Store content option for restoration after refresh
      localStorage.setItem('currentContentOption', contentOption);
      localStorage.setItem('processingStartTime', Date.now().toString());
      
      // Reset workflow steps based on selected content option
      resetWorkflowSteps(contentOption);
      
      processKeywordsInSequence(selectedKeywords, contentOption);
    }
    });
  } else {
    console.warn('⚠️ processSelectedBtn element not found!');
  }
  
  // MODIFIED BATCH PROCESSING: Add delays between requests to avoid Discord spam detection
  async function processKeywordsInSequence(keywordIds, contentOption) {
    const total = keywordIds.length;
    const results = [];
    const startTime = Date.now();
    
    // Clear cancellation flag when starting new processing
    window.processingCancelled = false;
    window.countedKeywords = new Set(); // Clear double-counting tracker
    console.log('🚀 Cleared cancellation flag and counter tracking, starting new processing');
    
    const progressBar = document.querySelector('.progress-bar');
    const progressText = document.getElementById('progressText');
    
    // Start elapsed time counter
    window.processingTimeInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      document.getElementById('elapsedTime').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
    
    console.log(`🚀 Starting TRUE sequential processing for ${total} keywords (one at a time)`);
    
    // Process only the first keyword initially, others will be processed by the monitoring system
    const firstKeywordId = keywordIds[0];
    
    // Set initial workflow state for first keyword
    showWorkflowProgress('recipe', `Keyword 1/${total}`);
    
    // Update simple progress
    const progressPercent = Math.round((1 / total) * 50); // Only show 50% during initialization
    progressBar.style.width = `${progressPercent}%`;
    progressBar.setAttribute('aria-valuenow', progressPercent);
    document.getElementById('progressPercentage').textContent = `${progressPercent}%`;
    
    // Update UI to processing immediately
    updateKeywordRowInUI(firstKeywordId, { status: 'processing' });
    
    // Start processing request for ONLY the first keyword
    fetch('/api/keywords/process-selected', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache'
      },
      body: JSON.stringify({
        keywordIds: [firstKeywordId],
        contentOption: contentOption,
        ...getSelectedTemplate()
      })
    })
    .then(response => {
      if (response.ok) {
        console.log(`✅ Processing started for keyword 1/${total}`);
      } else {
        console.error(`❌ Failed to start processing keyword 1/${total}`);
        updateKeywordRowInUI(firstKeywordId, { status: 'failed', message: 'Server error' });
      }
    })
    .catch(error => {
      console.log(`⚠️ Network timeout for keyword 1/${total}, monitoring status...`);
      // Even on timeout, we'll monitor via polling
    });
    
    // Update progress to show all requests started
    progressBar.style.width = '75%';
    progressBar.setAttribute('aria-valuenow', 75);
    progressText.textContent = `All ${total} keywords sent to processing pipeline (with spam protection)!`;
    
    // Start polling all keywords for status updates (use original working system)
    console.log('🔄 Starting batch status monitoring...');
    startBatchStatusMonitoringWithProgressCounters(keywordIds, contentOption);
    
    // Update status after workflow simulations
    setTimeout(() => {
      const progressText = document.getElementById('progressText');
      if (progressText) {
        progressText.textContent = `Monitoring content generation progress...`;
      }
    }, 2000);
  }
  
  // Auto-start next keyword for sequential processing
  function startNextKeywordIfAvailable(keywordIds, completedKeywords, startedKeywords, contentOption) {
    console.log(`🔍 Checking for next keyword to start. Completed: ${completedKeywords.size}/${keywordIds.length}, Started: ${startedKeywords.size}/${keywordIds.length}`);
    console.log(`Completed keywords:`, Array.from(completedKeywords));
    console.log(`Started keywords:`, Array.from(startedKeywords));
    console.log(`All keywords:`, keywordIds);
    
    // Check for cancellation flag
    if (window.processingCancelled) {
      console.log('🛑 Processing cancelled, not starting next keyword');
      return;
    }
    
    // Find the first keyword that hasn't been started yet
    const nextKeywordId = keywordIds.find(id => !startedKeywords.has(id));
    
    if (nextKeywordId) {
      const keywordIndex = keywordIds.indexOf(nextKeywordId) + 1;
      const total = keywordIds.length;
      
      console.log(`🚀 Auto-starting next keyword ${keywordIndex}/${total}: ${nextKeywordId}`);
      
      // Mark this keyword as started IMMEDIATELY to prevent race conditions
      startedKeywords.add(nextKeywordId);
      
      // Update UI to processing
      updateKeywordRowInUI(nextKeywordId, { status: 'processing' });
      
      // Set workflow state
      showWorkflowProgress('recipe', `Keyword ${keywordIndex}/${total}`);
      
      // Start processing with better error handling
      fetch('/api/keywords/process-selected', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        },
        body: JSON.stringify({
          keywordIds: [nextKeywordId],
          contentOption: contentOption,
          ...getSelectedTemplate()
        })
      })
      .then(response => {
        if (response.ok) {
          console.log(`✅ Next keyword processing started: ${nextKeywordId}`);
          // Keyword already marked as started above
        } else {
          console.error(`❌ Failed to start next keyword: ${nextKeywordId} - Status: ${response.status}`);
          // Remove from started set since it failed to start
          startedKeywords.delete(nextKeywordId);
          updateKeywordRowInUI(nextKeywordId, { status: 'failed', message: 'Server error' });
          updateProgressCounters('failed');
          // Try to start the next keyword after this failure
          setTimeout(() => startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption), 5000);
        }
      })
      .catch(error => {
        console.error(`❌ Network error starting next keyword: ${nextKeywordId}`, error);
        // Remove from started set since it failed to start
        startedKeywords.delete(nextKeywordId);
        updateKeywordRowInUI(nextKeywordId, { status: 'failed', message: 'Network error' });
        updateProgressCounters('failed');
        // Try to start the next keyword after this failure
        setTimeout(() => startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption), 5000);
      });
    } else {
      console.log(`✅ No more keywords to start. All ${keywordIds.length} keywords completed.`);
    }
  }
  
  // Enhanced batch monitoring that updates the progress counters correctly
  function startBatchStatusMonitoringWithProgressCounters(keywordIds, contentOption) {
    // Clear any existing monitoring interval first
    if (window.batchMonitoringInterval) {
      clearInterval(window.batchMonitoringInterval);
      console.log('🔄 Cleared existing monitoring interval');
    }
    
    const completedKeywords = new Set();
    // Store startedKeywords globally so other functions can access it
    window.startedKeywords = new Set();
    // Mark first keyword as started since we start it in processKeywordsInSequence
    window.startedKeywords.add(keywordIds[0]);
    let checkCount = 0;
    const maxChecks = 120; // Check for up to 20 minutes (120 * 10s)
    
    // Store the interval globally so we can stop it
    window.batchMonitoringInterval = setInterval(async () => {
      checkCount++;
      console.log(`📡 Batch status check ${checkCount}/${maxChecks} - ${completedKeywords.size}/${keywordIds.length} completed, ${window.startedKeywords.size}/${keywordIds.length} started`);
      
      // Check for cancellation flag
      if (window.processingCancelled) {
        console.log('🛑 Processing cancelled, stopping monitoring');
        clearInterval(window.batchMonitoringInterval);
        window.batchMonitoringInterval = null;
        return;
      }
      
      for (const keywordId of keywordIds) {
        if (completedKeywords.has(keywordId)) continue; // Skip already completed
        
        try {
          const response = await fetch(`/api/keywords/status/${keywordId}`, {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' }
          });
          
          if (response.ok) {
            const data = await response.json();
            
            if (data.status === 'processed') {
              completedKeywords.add(keywordId);
              updateKeywordRowInUI(keywordId, data);
              updateWorkflowBasedOnStatus(keywordId, 'processed', data);
              updateProgressCounters('processed', keywordId); // UPDATE COUNTERS WITH ID!
              
              // Start image monitoring for this keyword
              if (data.recipeId) {
                setTimeout(() => startSmartImageMonitoring(data.recipeId, keywordId), 10000);
              }
              
              // AUTO-START NEXT KEYWORD (sequential processing)
              startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption);
              
            } else if (data.status === 'failed') {
              completedKeywords.add(keywordId);
              updateKeywordRowInUI(keywordId, data);
              updateWorkflowBasedOnStatus(keywordId, 'failed', data);
              updateProgressCounters('failed', keywordId); // UPDATE COUNTERS WITH ID!
              
              // AUTO-START NEXT KEYWORD (sequential processing)
              startNextKeywordIfAvailable(keywordIds, completedKeywords, window.startedKeywords, contentOption);
            } else if (data.status === 'processing') {
              // Update workflow for ongoing processing
              updateWorkflowBasedOnStatus(keywordId, 'processing', data);
            }
            // If still processing, keep checking
          }
        } catch (error) {
          // Continue checking on errors
        }
      }
      
      // Stop when all completed or max checks reached
      if (completedKeywords.size >= keywordIds.length || checkCount >= maxChecks) {
        clearInterval(window.batchMonitoringInterval);
        window.batchMonitoringInterval = null;
        clearInterval(window.processingTimeInterval);
        
        const remaining = keywordIds.length - completedKeywords.size;
        const successCount = parseInt(document.getElementById('successCount').textContent) || 0;
        const failedCount = parseInt(document.getElementById('failedCount').textContent) || 0;
        
        // Final progress update
        const progressBar = document.querySelector('.progress-bar');
        progressBar.style.width = '100%';
        progressBar.setAttribute('aria-valuenow', 100);
        
        if (remaining > 0) {
          showStatus('warning', `${completedKeywords.size}/${keywordIds.length} completed. ${remaining} still processing - refresh to check status.`);
        } else if (failedCount === 0) {
          progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--accent-teal) 0%, #4aecbf 100%)';
          showStatus('success', `✅ All ${keywordIds.length} keywords completed successfully!`);
        } else {
          progressBar.style.backgroundImage = 'linear-gradient(90deg, var(--accent-amber) 0%, #ffcf9c 100%)';
          showStatus('success', `✅ Batch completed: ${successCount} successful, ${failedCount} failed.`);
        }
        
        // Don't hide progress automatically during sequential processing
        // The progress will be hidden when the user manually refreshes or navigates away
      }
    }, 10000); // Check every 10 seconds
  }
  
  // Monitor multiple keywords during batch processing
  function startBatchStatusMonitoring(keywordIds) {
    // Don't start if enhanced monitoring is already running
    if (window.batchMonitoringInterval) {
      console.log('⚠️ Enhanced monitoring already running, skipping old monitoring function');
      return;
    }
    
    const completedKeywords = new Set();
    let checkCount = 0;
    const maxChecks = 120; // Check for up to 20 minutes (120 * 10s)
    
    // Store the interval globally so we can stop it
    window.batchMonitoringInterval = setInterval(async () => {
      checkCount++;
      console.log(`📡 Batch status check ${checkCount}/${maxChecks} - ${completedKeywords.size}/${keywordIds.length} completed`);
      
      for (const keywordId of keywordIds) {
        if (completedKeywords.has(keywordId)) continue; // Skip already completed
        
        try {
          const response = await fetch(`/api/keywords/status/${keywordId}`, {
            method: 'GET',
            headers: { 'Cache-Control': 'no-cache' }
          });
          
          if (response.ok) {
            const data = await response.json();
            
            if (data.status === 'processed') {
              completedKeywords.add(keywordId);
              updateKeywordRowInUI(keywordId, data);
              updateWorkflowBasedOnStatus(keywordId, 'processed', data);
              
              // Start image monitoring for this keyword
              if (data.recipeId) {
                setTimeout(() => startSmartImageMonitoring(data.recipeId, keywordId), 10000);
              }
              
            } else if (data.status === 'failed') {
              completedKeywords.add(keywordId);
              updateKeywordRowInUI(keywordId, data);
              updateWorkflowBasedOnStatus(keywordId, 'failed', data);
            } else if (data.status === 'processing') {
              // Update workflow for ongoing processing
              updateWorkflowBasedOnStatus(keywordId, 'processing', data);
            }
            // If still processing, keep checking
          }
        } catch (error) {
          // Continue checking on errors
        }
      }
      
      // Stop when all completed or max checks reached
      if (completedKeywords.size >= keywordIds.length || checkCount >= maxChecks) {
        clearInterval(window.batchMonitoringInterval);
        window.batchMonitoringInterval = null;
        const remaining = keywordIds.length - completedKeywords.size;
        
        if (remaining > 0) {
          showStatus('warning', `${completedKeywords.size}/${keywordIds.length} completed. ${remaining} still processing - refresh to check status.`);
        } else {
          showStatus('success', `All ${keywordIds.length} keywords completed successfully!`);
        }
      }
    }, 10000); // Check every 10 seconds
  }

  // Initialize tracking for counted keywords to prevent double counting
  window.countedKeywords = window.countedKeywords || new Set();
  
  // Simplified progress counter updates with comprehensive debugging
  function updateProgressCounters(status, keywordId = null) {
    console.log(`🔢 updateProgressCounters called with status: ${status}, keywordId: ${keywordId}`);
    console.log(`🔢 Call stack:`, new Error().stack.split('\n')[1].trim());
    
    const successElement = document.getElementById('successCount');
    const failedElement = document.getElementById('failedCount');
    const remainingElement = document.getElementById('remainingCount');
    const progressCountElement = document.getElementById('progressCount');
    
    if (!successElement || !failedElement) {
      console.log(`🔢 Missing elements, returning`);
      return;
    }
    
    let currentSuccess = parseInt(successElement.textContent) || 0;
    let currentFailed = parseInt(failedElement.textContent) || 0;
    
    console.log(`🔢 Before update: Success=${currentSuccess}, Failed=${currentFailed}`);
    
    // Prevent double counting if keywordId is provided
    if (keywordId) {
      const countKey = `${keywordId}-${status}`;
      if (window.countedKeywords.has(countKey)) {
        console.log(`⚠️ Preventing double count for keyword ${keywordId} status ${status}`);
        return;
      }
      window.countedKeywords.add(countKey);
      console.log(`📊 First time counting keyword ${keywordId} as ${status}`);
    }
    
    if (status === 'processed') {
      currentSuccess++;
      successElement.textContent = currentSuccess;
      console.log(`🔢 After processed update: Success now = ${currentSuccess}`);
      // Mark completed steps as completed (get visible steps only)
      const visibleSteps = document.querySelectorAll('.workflow-step');
      visibleSteps.forEach(stepElement => {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'completed');
        }
      });
    } else if (status === 'failed') {
      currentFailed++;
      failedElement.textContent = currentFailed;
      console.log(`🔢 After failed update: Failed now = ${currentFailed}`);
      // Mark first visible step as failed
      const visibleSteps = document.querySelectorAll('.workflow-step');
      for (const stepElement of visibleSteps) {
        if (stepElement.closest('.col').style.display !== 'none') {
          const stepId = stepElement.id.replace('step-', '');
          updateWorkflowStep(stepId, 'failed');
          break; // Only mark the first step as failed
        }
      }
    }
    
    // Update simple counters
    const totalProcessed = currentSuccess + currentFailed;
    const totalText = progressCountElement.textContent;
    const total = parseInt(totalText.split(' / ')[1]) || 0;
    const remaining = Math.max(0, total - totalProcessed);
    
    remainingElement.textContent = remaining;
    progressCountElement.textContent = `${totalProcessed} / ${total}`;
    
    // Update progress bar
    if (total > 0) {
      const percentage = Math.round((totalProcessed / total) * 100);
      document.getElementById('progressPercentage').textContent = `${percentage}%`;
      
      const progressBar = document.querySelector('.progress-bar');
      if (progressBar) {
        progressBar.style.width = `${percentage}%`;
        progressBar.setAttribute('aria-valuenow', percentage);
      }
      
      // Check completion
      if (totalProcessed >= total) {
        completeProcessing(currentSuccess, currentFailed);
      }
    }
  }
  
  function completeProcessing(successCount, failedCount) {
    // Clear timer
    if (window.processingTimeInterval) {
      clearInterval(window.processingTimeInterval);
      window.processingTimeInterval = null;
    }
    
    // Clear localStorage since processing is complete
    localStorage.removeItem('currentContentOption');
    localStorage.removeItem('processingStartTime');
    
    // Update status
    document.getElementById('progressText').textContent = 
      `Processing completed! ${successCount} successful, ${failedCount} failed.`;
    document.getElementById('currentKeyword').textContent = '';
    
    // Change progress bar style
    const progressBar = document.querySelector('.progress-bar');
    if (progressBar) {
      progressBar.classList.remove('progress-bar-animated');
      if (failedCount === 0) {
        progressBar.style.backgroundImage = 'linear-gradient(90deg, #28a745 0%, #34ce57 100%)';
      } else {
        progressBar.style.backgroundImage = 'linear-gradient(90deg, #ffc107 0%, #ffdb4d 100%)';
      }
    }
    
    // Don't auto-hide during sequential processing - let user manually close or navigate away
    // Sequential processing keeps progress visible for better user experience
  }

  // NEW SIMPLE UPDATE FUNCTION
  function updateKeywordRowInUI(keywordId, result) {
    try {
      const card = document.querySelector(`.keyword-card[data-id="${keywordId}"]`);
      if (!card) {
        console.warn(`Card not found for keyword: ${keywordId}`);
        return;
      }
      
      console.log(`🔄 Updating UI for keyword ${keywordId}:`, result.status);
      
      // Progress counters are updated by the monitoring logic to prevent double-counting
      // Do not update counters here as it causes duplicate counts
      
      // Update content status badge
      const contentBadge = card.querySelector('[data-badge="content"]');
      if (contentBadge) {
        if (result.status === 'processing') {
          contentBadge.className = 'badge bg-info me-2';
          contentBadge.textContent = '🔄 PROCESSING';
        } else if (result.status === 'already_processing') {
          contentBadge.className = 'badge bg-info me-2';
          contentBadge.textContent = '⏳ PROCESSING';
          return; // Don't update anything else
        } else if (result.status === 'processed') {
          contentBadge.className = 'badge bg-success me-2';
          contentBadge.textContent = '✅ COMPLETED';
          
          // Update image badge to show pending (monitoring will start in 60s)
          const imageBadge = card.querySelector('[data-badge="image"]');
          if (imageBadge && result.recipeId) {
            imageBadge.className = 'badge bg-secondary me-2';
            imageBadge.textContent = '🖼️ PENDING';
            imageBadge.setAttribute('data-recipe-id', result.recipeId);
          }
          
          // Update action buttons
          const actionsDiv = card.querySelector('.btn-group-vertical');
          if (actionsDiv && result.recipeId) {
            actionsDiv.innerHTML = `
              <a href="/recipe/${result.recipeId}" class="btn btn-sm btn-primary mb-1">
                <i class="bi bi-eye"></i> View
              </a>
              <button type="button" class="btn btn-sm btn-info regenerate-image-btn mb-1" data-recipe-id="${result.recipeId}">
                <i class="bi bi-arrow-repeat"></i> Regenerate
              </button>
            `;
          }
          
          // Disable checkbox
          const checkbox = card.querySelector('.keyword-checkbox');
          if (checkbox) {
            checkbox.disabled = true;
            checkbox.checked = false;
          }
          
        } else if (result.status === 'failed') {
          contentBadge.className = 'badge bg-danger me-2';
          contentBadge.textContent = '❌ FAILED';
        } else if (result.status === 'pending') {
          contentBadge.className = 'badge bg-warning me-2';
          contentBadge.textContent = '📝 PENDING';
        }
      }
      
      // Update card data attribute
      card.setAttribute('data-status', result.status);
      
      console.log(`✅ UI updated for keyword ${keywordId}`); 
      
      card.style.backgroundColor = '#d4edda';
      setTimeout(() => {
        card.style.backgroundColor = '';
      }, 2000);
      
    } catch (error) {
      console.error(`Error updating UI for keyword ${keywordId}:`, error);
    }
  }
  
  // Process next pending keywords
  safeAddClickHandler('processNextBtn', function() {
    const optionElement = document.querySelector('input[name="contentOption"]:checked');
    const contentOption = optionElement ? optionElement.value : 'facebook';
    
    const pendingKeywords = Array.from(document.querySelectorAll('.keyword-card[data-status="pending"]'))
      .map(card => card.getAttribute('data-id'))
      .slice(0, 5);
    
    if (pendingKeywords.length === 0) {
      alert('No pending keywords found.');
      return;
    }
    
    if (confirm(`Process ${pendingKeywords.length} pending keywords with ${contentOption} option?`)) {
      const statusElement = document.getElementById('statusMessage');
      if (statusElement) {
        statusElement.innerHTML = '<div class="alert alert-info">Processing keywords, please wait...</div>';
      }
      
      const progressElement = document.getElementById('processingProgress');
      const progressBar = progressElement.querySelector('.progress-bar');
      const progressText = document.getElementById('progressText');
      
      progressElement.classList.remove('d-none');
      progressBar.style.width = '0%';
      progressBar.setAttribute('aria-valuenow', 0);
      progressText.textContent = '🔄 Preparing batch processing - Analyzing keywords and content options...';
      
      processKeywordsInSequence(pendingKeywords, contentOption);
    }
  });
  
  // Process buttons in the keywords list
  document.querySelectorAll('.process-btn').forEach(button => {
    button.addEventListener('click', function() {
      const keywordId = this.getAttribute('data-id');
      const optionElement = document.querySelector('input[name="contentOption"]:checked');
      const contentOption = optionElement ? optionElement.value : 'facebook';
      
      if (confirm(`Process this keyword with ${contentOption} option?`)) {
        const statusElement = document.getElementById('statusMessage');
        if (statusElement) {
          statusElement.innerHTML = '<div class="alert alert-info">Processing keyword, please wait...</div>';
        }
        
        // IMMEDIATELY update UI to show processing status
        updateKeywordRowInUI(keywordId, { status: 'processing' });
        
        // ASYNC PROCESSING: Start request but don't wait for full response
        console.log('🚀 Starting async processing for keyword:', keywordId);
        showStatus('info', 'Processing started, monitoring progress...');
        
        // Start the processing request (don't wait for response)
        fetch('/api/keywords/process-selected', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            keywordIds: [keywordId],
            contentOption: contentOption,
            ...getSelectedTemplate()
          })
        })
        .then(response => {
          if (response.ok) {
            console.log('✅ Processing request accepted by server');
            // Start polling for status updates
            startKeywordStatusPolling(keywordId);
          } else {
            console.error('❌ Server rejected processing request');
            updateKeywordRowInUI(keywordId, { status: 'failed', message: 'Server error' });
          }
        })
        .catch(error => {
          console.log('⚠️ Network timeout detected, starting polling anyway...');
          console.log('📡 Reason: Cloudways cuts off long requests, but processing continues on server');
          
          // The request probably started but timed out - start polling
          startKeywordStatusPolling(keywordId);
        });
      }
    });
  });
  
  // Retry buttons
  document.querySelectorAll('.retry-btn').forEach(button => {
    button.addEventListener('click', function() {
      const keywordId = this.getAttribute('data-id');
      const optionElement = document.querySelector('input[name="contentOption"]:checked');
      const contentOption = optionElement ? optionElement.value : 'facebook';
      
      if (confirm(`Retry processing this keyword with ${contentOption} option?`)) {
        const statusElement = document.getElementById('statusMessage');
        if (statusElement) {
          statusElement.innerHTML = '<div class="alert alert-info">Processing keyword, please wait...</div>';
        }
        
        // IMMEDIATELY update UI to show processing status
        updateKeywordRowInUI(keywordId, { status: 'processing' });
        
        // ASYNC PROCESSING: Start request but don't wait for full response
        console.log('🔄 Starting async retry processing for keyword:', keywordId);
        showStatus('info', 'Retry processing started, monitoring progress...');
        
        // Start the processing request (don't wait for response)
        fetch('/api/keywords/process-selected', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            keywordIds: [keywordId],
            contentOption: contentOption,
            ...getSelectedTemplate()
          })
        })
        .then(response => {
          if (response.ok) {
            console.log('✅ Retry processing request accepted by server');
            // Start polling for status updates
            startKeywordStatusPolling(keywordId);
          } else {
            console.error('❌ Server rejected retry processing request');
            updateKeywordRowInUI(keywordId, { status: 'failed', message: 'Server error' });
          }
        })
        .catch(error => {
          console.log('⚠️ Network timeout detected during retry, starting polling anyway...');
          
          // The request probably started but timed out - start polling
          startKeywordStatusPolling(keywordId);
        });
      }
    });
  });
  
  // Delete selected keywords
  const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
  if (deleteSelectedBtn) {
    deleteSelectedBtn.addEventListener('click', function() {
      const selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
        .map(cb => cb.value);
        
      if (selectedKeywords.length === 0) {
        alert('No keywords selected for deletion.');
        return;
      }
      
      if (confirm(`Are you sure you want to delete ${selectedKeywords.length} selected keywords? This action cannot be undone.`)) {
        deleteKeywords(selectedKeywords);
      }
    });
  }
  
  // Delete buttons
  document.querySelectorAll('.delete-btn').forEach(button => {
    button.addEventListener('click', function() {
      const keywordId = this.getAttribute('data-id');
      
      if (confirm('Are you sure you want to delete this keyword? This action cannot be undone.')) {
        deleteKeywords([keywordId]);
      }
    });
  });
      
  // Helper function: Delete keywords
  async function deleteKeywords(keywordIds) {
    if (!keywordIds || keywordIds.length === 0) {
      showStatus('error', 'No keywords selected for deletion.');
      return;
    }
    
    try {
      const response = await fetch('/api/keywords/delete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ keywordIds })
      });
      
      const data = await response.json();
      
      if (data.success) {
        showStatus('success', data.message || `Deleted ${data.count} keywords successfully`);
        
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        throw new Error(data.message || 'Failed to delete keywords');
      }
    } catch (error) {
      console.error('Error deleting keywords:', error);
      showStatus('error', error.message || 'An unknown error occurred');
    }
  }
  
  // Add event listeners for regenerate image buttons
  document.querySelectorAll('.regenerate-image-btn').forEach(button => {
    button.addEventListener('click', async function() {
      const recipeId = this.getAttribute('data-recipe-id');
      if (!recipeId) {
        showStatus('error', 'Recipe ID not found for regeneration');
        return;
      }
      
      if (confirm('Are you sure you want to regenerate the image for this recipe?')) {
        try {
          this.disabled = true;
          const originalText = this.innerHTML;
          this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Regenerating...';
          
          const response = await fetch(`/midjourney/api/generate/${recipeId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          const data = await response.json();
          
          if (data.success) {
            showStatus('success', 'Image generation started successfully');
            
            const statusCell = document.querySelector(`.image-status-cell[data-recipe-id="${recipeId}"]`);
            if (statusCell) {
              statusCell.innerHTML = `<span class="badge bg-warning">⏳ Pending</span>`;
            }
            
            setTimeout(() => {
              this.disabled = false;
              this.innerHTML = originalText;
            }, 3000);
          } else {
            showStatus('error', data.error || 'Failed to regenerate image');
            this.disabled = false;
            this.innerHTML = originalText;
          }
        } catch (error) {
          console.error('Error regenerating image:', error);
          showStatus('error', error.message || 'An unknown error occurred');
          this.disabled = false;
          this.innerHTML = originalText;
        }
      }
    });
  });

  // Fix date formatting using date-fns
  function formatDates() {
    document.querySelectorAll('.date-cell').forEach(cell => {
      const dateStr = cell.getAttribute('data-date');
      if (dateStr) {
        try {
          const date = new Date(dateStr);
          const timeAgo = dateFns.formatDistanceToNow(date, { addSuffix: true });
          const formattedDate = dateFns.format(date, 'PPpp');
          
          cell.innerHTML = `<span title="${formattedDate}">${timeAgo}</span>`;
        } catch (error) {
          console.error('Error formatting date:', error);
          const date = new Date(dateStr);
          cell.innerHTML = date.toLocaleString();
        }
      }
    });
  }
    
  // Sort cards by date when needed
  function sortRowsByDate() {
    const container = document.querySelector('.keywords-vertical-list');
    if (!container) return;
    
    const cards = Array.from(container.querySelectorAll('.keyword-card[data-added]'));
    
    cards.sort((a, b) => {
      const dateA = new Date(a.getAttribute('data-added') || 0);
      const dateB = new Date(b.getAttribute('data-added') || 0);
      return dateB - dateA;
    });
    
    cards.forEach(card => container.appendChild(card));
  }
  
  // Excel file input handler for PinClicks
  const pinclicksExcelFileInput = document.getElementById('pinclicksExcelFile');
  if (pinclicksExcelFileInput) {
    pinclicksExcelFileInput.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) {
        document.getElementById('pinclicksExcelPreview').classList.add('d-none');
        parsedPinclicksData = null;
        return;
      }
      
      const allowedTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv'
      ];
      
      if (!allowedTypes.includes(file.type) && !file.name.match(/\.(xlsx|xls|csv)$/i)) {
        showStatus('error', 'Please upload a valid Excel file (.xlsx, .xls) or CSV file.');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          let workbook;
          
          if (file.name.toLowerCase().endsWith('.csv')) {
            const csvData = e.target.result;
            
            // Parse CSV using the same robust logic as the Excel tab
            try {
              const lines = [];
              let currentLine = '';
              let insideQuotes = false;
              let quoteChar = null;
              
              for (let i = 0; i < csvData.length; i++) {
                const char = csvData[i];
                
                if ((char === '"' || char === "'") && !insideQuotes) {
                  insideQuotes = true;
                  quoteChar = char;
                  currentLine += char;
                } else if (char === quoteChar && insideQuotes) {
                  if (i + 1 < csvData.length && csvData[i + 1] === quoteChar) {
                    currentLine += char + char;
                    i++;
                  } else {
                    insideQuotes = false;
                    quoteChar = null;
                    currentLine += char;
                  }
                } else if (char === '\n' && !insideQuotes) {
                  if (currentLine.trim()) {
                    lines.push(currentLine.trim());
                  }
                  currentLine = '';
                } else {
                  currentLine += char;
                }
              }
              
              if (currentLine.trim()) {
                lines.push(currentLine.trim());
              }
              
              if (lines.length === 0) {
                throw new Error('No data found in CSV');
              }
              
              const headers = parseCSVLine(lines[0]);
              const rows = [];
              for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim()) {
                  const values = parseCSVLine(line);
                  const row = {};
                  headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                  });
                  rows.push(row);
                }
              }
              
              parsedPinclicksData = {
                headers: headers,
                data: rows
              };
              
            } catch (csvError) {
              console.error('CSV parsing failed:', csvError);
              showStatus('error', 'Failed to parse CSV. Please ensure your file is properly formatted.');
              return;
            }
            
          } else {
            workbook = XLSX.read(e.target.result, { type: 'binary' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            if (jsonData.length === 0) {
              showStatus('error', 'The uploaded file appears to be empty.');
              return;
            }
            
            const headers = jsonData[0];
            const data = jsonData.slice(1).filter(row => row.some(cell => cell !== undefined && cell !== '')).map(row => {
              const rowObj = {};
              headers.forEach((header, index) => {
                rowObj[header] = row[index] || '';
              });
              return rowObj;
            });
            
            parsedPinclicksData = {
              headers: headers,
              data: data
            };
          }
          
          // Validate required columns
          const requiredColumns = ['keyword'];
          const optionalColumns = ['interests', 'keywords', 'category', 'imageurl'];
          const allColumns = [...requiredColumns, ...optionalColumns];
          
          const headerLower = parsedPinclicksData.headers.map(h => h.toLowerCase());
          const missingRequired = requiredColumns.filter(col => 
            !headerLower.some(h => h.includes(col.toLowerCase()))
          );
          
          if (missingRequired.length > 0) {
            showStatus('error', `Missing required column: "Keyword". Please ensure your file has a column containing the main keywords.`);
            return;
          }
          
          // Create column mapping
          const columnMap = {};
          allColumns.forEach(col => {
            const matchedHeader = parsedPinclicksData.headers.find(h => 
              h.toLowerCase().includes(col.toLowerCase())
            );
            if (matchedHeader) {
              columnMap[col] = matchedHeader;
            }
          });
          
          // Try to find interests/keywords column
          if (!columnMap.interests && !columnMap.keywords) {
            // Look for any column that might contain interests
            const possibleInterestColumns = parsedPinclicksData.headers.filter(h => 
              h.toLowerCase().includes('interest') || 
              h.toLowerCase().includes('tag') ||
              h.toLowerCase().includes('topic') ||
              h.toLowerCase().includes('related')
            );
            
            if (possibleInterestColumns.length > 0) {
              columnMap.interests = possibleInterestColumns[0];
            }
          }
          
          const normalizedData = parsedPinclicksData.data.map(row => {
            const normalized = {};
            Object.keys(columnMap).forEach(key => {
              const headerName = columnMap[key];
              normalized[key] = row[headerName] || '';
            });
            return normalized;
          }).filter(row => row.keyword && row.keyword.trim());
          
          if (normalizedData.length === 0) {
            showStatus('error', 'No valid data found in the file. Please check that you have keywords in the correct column.');
            return;
          }
          
          parsedPinclicksData.normalizedData = normalizedData;
          parsedPinclicksData.columnMap = columnMap;
          
          displayPinclicksExcelPreview(parsedPinclicksData);
          
        } catch (error) {
          console.error('Error parsing file:', error);
          showStatus('error', 'Error reading file: ' + error.message);
        }
      };
      
      if (file.name.toLowerCase().endsWith('.csv')) {
        reader.readAsText(file);
      } else {
        reader.readAsBinaryString(file);
      }
    });
  }

  // Helper function to parse CSV line (same as used in Excel tab)
  function parseCSVLine(line) {
    const values = [];
    let currentValue = '';
    let insideQuotes = false;
    let quoteChar = null;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if ((char === '"' || char === "'") && !insideQuotes) {
        insideQuotes = true;
        quoteChar = char;
      } else if (char === quoteChar && insideQuotes) {
        if (i + 1 < line.length && line[i + 1] === quoteChar) {
          currentValue += char;
          i++;
        } else {
          insideQuotes = false;
          quoteChar = null;
        }
      } else if (char === ',' && !insideQuotes) {
        values.push(currentValue.trim());
        currentValue = '';
      } else {
        currentValue += char;
      }
    }
    
    values.push(currentValue.trim());
    return values;
  }

  // Function to display Excel preview for PinClicks
  function displayPinclicksExcelPreview(data) {
    const previewDiv = document.getElementById('pinclicksExcelPreview');
    const headerElement = document.getElementById('pinclicksExcelPreviewHeader');
    const bodyElement = document.getElementById('pinclicksExcelPreviewBody');
    
    if (!previewDiv || !headerElement || !bodyElement) return;
    
    headerElement.innerHTML = '';
    bodyElement.innerHTML = '';
    
    previewDiv.classList.remove('d-none');
    
    const headerRow = document.createElement('tr');
    const displayHeaders = ['Keyword', 'Interests/Keywords', 'Category', 'Image URL'];
    displayHeaders.forEach(header => {
      const th = document.createElement('th');
      th.textContent = header;
      headerRow.appendChild(th);
    });
    headerElement.appendChild(headerRow);
    
    const previewData = data.normalizedData.slice(0, 5);
    previewData.forEach(row => {
      const tr = document.createElement('tr');
      
      // Keyword
      const keywordTd = document.createElement('td');
      const keyword = row.keyword || '';
      keywordTd.textContent = keyword.length > 30 ? keyword.substring(0, 27) + '...' : keyword;
      keywordTd.title = keyword;
      tr.appendChild(keywordTd);
      
      // Interests/Keywords
      const interestsTd = document.createElement('td');
      const interests = row.interests || row.keywords || '';
      interestsTd.textContent = interests.length > 40 ? interests.substring(0, 37) + '...' : interests;
      if (interests.length > 40) {
        interestsTd.title = interests;
      }
      tr.appendChild(interestsTd);
      
      // Category
      const categoryTd = document.createElement('td');
      categoryTd.textContent = row.category || '';
      tr.appendChild(categoryTd);
      
      // Image URL
      const imageUrlTd = document.createElement('td');
      const imageUrl = row.imageurl || '';
      imageUrlTd.textContent = imageUrl.length > 30 ? imageUrl.substring(0, 27) + '...' : imageUrl;
      if (imageUrl.length > 30) {
        imageUrlTd.title = imageUrl;
      }
      tr.appendChild(imageUrlTd);
      
      bodyElement.appendChild(tr);
    });
    
    showStatus('success', 
      `File parsed successfully! Found ${data.normalizedData.length} keywords with interests. Preview shows first 5 rows.`
    );
  }

  // Enhanced PinClicks Analysis Button with Recipe Support
  const analyzePinclicksBtn = document.getElementById('analyzePinclicksBtn');
  if (analyzePinclicksBtn) {
    analyzePinclicksBtn.addEventListener('click', function() {
      const pinclicksFile = document.getElementById('pinclicksFile');
      const pinclicksExcelFile = document.getElementById('pinclicksExcelFile');
      const pinclicksRecipeInput = document.getElementById('pinclicksRecipeInput'); // Changed from pinclicksKeyword
      const pinclicksCategory = document.getElementById('pinclicksCategory');
      const pinclicksImageUrl = document.getElementById('pinclicksImageUrl');
      
      // Check which tab is active
      const csvTabActive = document.getElementById('pinclicks-csv').classList.contains('active');
      const excelTabActive = document.getElementById('pinclicks-excel').classList.contains('active');
      
      if (csvTabActive) {
        // Handle CSV upload with enhanced recipe support
        const file = pinclicksFile.files[0];
        const recipeInput = pinclicksRecipeInput.value.trim(); // Get recipe input instead of just keyword
        
        if (!file) {
          showStatus('error', 'Please upload a PinClicks CSV file.');
          return;
        }
        
        if (!recipeInput) {
          showStatus('error', 'Please enter a keyword or complete recipe for this analysis.');
          return;
        }
        
        // Detect if this is a full recipe or just a keyword (using the same logic as manual entry)
        const isFullRecipe = detectFullRecipe(recipeInput);
        
        let keyword;
        let fullRecipe = null;
        
        if (isFullRecipe) {
          // Extract title from full recipe (using the same logic as manual entry)
          keyword = extractRecipeTitle(recipeInput);
          fullRecipe = recipeInput;
          console.log(`PinClicks: Detected full recipe with title: "${keyword}"`);
        } else {
          // Simple keyword
          keyword = recipeInput;
          console.log(`PinClicks: Detected simple keyword: "${keyword}"`);
        }
        
        analyzePinclicksBtn.disabled = true;
        analyzePinclicksBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Analyzing...';
        
        const reader = new FileReader();
        reader.onload = function(e) {
          const csvData = e.target.result;
          
          fetch('/api/analyze-pinclicks', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              csv: csvData,
              keyword: keyword,
              full_recipe: fullRecipe, // Pass the full recipe if detected
              category: pinclicksCategory.value,
              image_url: pinclicksImageUrl.value
            })
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`Server responded with status: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            if (data.success) {
              analyzedPinclicksResults = [{
                keyword: keyword,
                full_recipe: fullRecipe, // Store the full recipe
                category: pinclicksCategory.value,
                interests: data.interests,
                image_url: pinclicksImageUrl.value
              }];
              
              displayPinclicksResults(analyzedPinclicksResults);
              
              document.getElementById('pinclicksAnalysisResult').classList.remove('d-none');
              document.getElementById('addFromPinclicksBtn').classList.remove('d-none');
              
              showStatus('success', 'Analysis complete! Review the extracted interests below.');
            } else {
              throw new Error(data.message || 'Failed to analyze PinClicks data');
            }
          })
          .catch(error => {
            console.error('Error analyzing PinClicks data:', error);
            showStatus('error', error.message || 'An unknown error occurred');
          })
          .finally(() => {
            analyzePinclicksBtn.disabled = false;
            analyzePinclicksBtn.innerHTML = 'Analyze File';
          });
        };
        
        reader.onerror = function(error) {
          console.error('Error reading file:', error);
          showStatus('error', 'Failed to read file');
          analyzePinclicksBtn.disabled = false;
          analyzePinclicksBtn.innerHTML = 'Analyze File';
        };
        
        reader.readAsText(file);
        
      } else if (excelTabActive) {
        // Handle Excel upload (existing logic unchanged)
        if (!parsedPinclicksData || !parsedPinclicksData.normalizedData) {
          showStatus('error', 'Please upload and preview an Excel file first.');
          return;
        }
        
        analyzePinclicksBtn.disabled = true;
        analyzePinclicksBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Analyzing...';
        
        // Process the parsed Excel data
        const defaultCategory = pinclicksCategory.value;
        const defaultImageUrl = pinclicksImageUrl.value;
        
        analyzedPinclicksResults = parsedPinclicksData.normalizedData.map(row => {
          return {
            keyword: row.keyword.trim(),
            category: row.category && row.category.trim() ? row.category.trim() : defaultCategory,
            interests: row.interests || row.keywords || 'food, recipes, cooking',
            image_url: row.imageurl && row.imageurl.trim() ? row.imageurl.trim() : defaultImageUrl
          };
        });
        
        displayPinclicksResults(analyzedPinclicksResults);
        
        document.getElementById('pinclicksAnalysisResult').classList.remove('d-none');
        document.getElementById('addFromPinclicksBtn').classList.remove('d-none');
        
        showStatus('success', `Analysis complete! Processed ${analyzedPinclicksResults.length} keywords with interests.`);
        
        analyzePinclicksBtn.disabled = false;
        analyzePinclicksBtn.innerHTML = 'Analyze File';
      }
    });
  }

  // Function to display PinClicks results with recipe detection
  function displayPinclicksResults(results) {
    const container = document.getElementById('pinclicksResultsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (results.length === 1) {
      // Single result (CSV mode)
      const result = results[0];
      container.innerHTML = `
        <p><strong>Extracted Interests:</strong></p>
        <div class="p-3 bg-light rounded">${result.interests}</div>
      `;
      
      // Show whether it's a full recipe or keyword
      if (result.full_recipe) {
        container.innerHTML += `<div class="alert alert-info mt-2">
          <strong>📝 Full Recipe Detected:</strong> "${result.keyword}"<br>
          <small>Complete recipe will be stored with these extracted interests.</small>
        </div>`;
      } else {
        container.innerHTML += `<div class="alert alert-warning mt-2">
          <strong>🤖 Keyword Detected:</strong> "${result.keyword}"<br>
          <small>AI will generate a full recipe with these extracted interests.</small>
        </div>`;
      }
    } else {
      // Multiple results (Excel mode)
      container.innerHTML = `
        <p><strong>Processed ${results.length} Keywords:</strong></p>
        <div class="table-responsive">
          <table class="table table-sm">
            <thead>
              <tr>
                <th>Keyword</th>
                <th>Interests</th>
                <th>Category</th>
              </tr>
            </thead>
            <tbody>
              ${results.map(result => `
                <tr>
                  <td><strong>${result.keyword}</strong></td>
                  <td>${result.interests.length > 50 ? result.interests.substring(0, 47) + '...' : result.interests}</td>
                  <td>${result.category || 'Default'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      `;
    }
  }

  // Enhanced Add from PinClicks button with recipe support
  const addFromPinclicksBtn = document.getElementById('addFromPinclicksBtn');
  if (addFromPinclicksBtn) {
    addFromPinclicksBtn.addEventListener('click', function() {
      if (!analyzedPinclicksResults || analyzedPinclicksResults.length === 0) {
        showStatus('error', 'Please analyze the file first.');
        return;
      }
      
      addFromPinclicksBtn.disabled = true;
      addFromPinclicksBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Adding...';
      
      // Prepare the data in the same format as manual entry and Excel upload
      const keywordsData = analyzedPinclicksResults.map(result => ({
        keyword: result.keyword,
        full_recipe: result.full_recipe, // Include full recipe if available
        category: result.category,
        interests: result.interests,
        image_url: result.image_url
      }));
      
      console.log('Adding PinClicks keywords:', keywordsData.map(item => ({
        keyword: item.keyword,
        has_full_recipe: !!item.full_recipe,
        category: item.category
      })));
      
      fetch('/api/keywords/add', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          keywords: keywordsData // Send as array to match the expected format
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          const count = analyzedPinclicksResults.length;
          if (count === 1) {
            const recipeType = analyzedPinclicksResults[0].full_recipe ? 'recipe' : 'keyword';
            showStatus('success', `Successfully added ${recipeType} "${analyzedPinclicksResults[0].keyword}" with extracted interests!`);
          } else {
            showStatus('success', `Successfully added ${count} keyword${count > 1 ? 's' : ''} with extracted interests!`);
          }
          
          // Reset form
          document.getElementById('pinclicksFile').value = '';
          document.getElementById('pinclicksExcelFile').value = '';
          document.getElementById('pinclicksRecipeInput').value = ''; // Changed from pinclicksKeyword
          document.getElementById('pinclicksCategory').value = '';
          document.getElementById('pinclicksImageUrl').value = '';
          document.getElementById('pinclicksAnalysisResult').classList.add('d-none');
          document.getElementById('pinclicksExcelPreview').classList.add('d-none');
          addFromPinclicksBtn.classList.add('d-none');
          analyzedPinclicksResults = null;
          parsedPinclicksData = null;
          
          setTimeout(() => {
            window.location.reload();
          }, 1500);
        } else {
          throw new Error(data.message || 'Failed to add keywords');
        }
      })
      .catch(error => {
        console.error('Error adding keywords from PinClicks:', error);
        showStatus('error', error.message || 'An unknown error occurred');
      })
      .finally(() => {
        addFromPinclicksBtn.disabled = false;
        addFromPinclicksBtn.innerHTML = 'Add Keywords with Interests';
      });
    });
  }
  
  // Prompt editing functionality
  const promptEditModal = document.getElementById('promptEditModal');
  if (promptEditModal) {
    let promptEditModalInstance = new bootstrap.Modal(promptEditModal);
    
    const promptEditSaveBtn = document.getElementById('promptEditSaveBtn');
    if (promptEditSaveBtn) {
      promptEditSaveBtn.addEventListener('click', async function() {
        const recipeId = document.getElementById('promptEditRecipeId').value;
        const prompt = document.getElementById('promptEditText').value;
        
        if (!recipeId || !prompt.trim()) {
          document.getElementById('promptEditAlert').classList.remove('d-none');
          document.getElementById('promptEditBlockedTerms').textContent = 'Please provide a valid prompt.';
          return;
        }
        
        promptEditSaveBtn.disabled = true;
        promptEditSaveBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Generating...';
        document.getElementById('promptEditForm').classList.add('d-none');
        document.getElementById('promptEditSpinner').classList.remove('d-none');
        
        try {
          const response = await fetch('/midjourney/api/generate-with-prompt', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              recipeId,
              prompt
            })
          });
          
          const data = await response.json();
          
          if (data.success) {
            promptEditModalInstance.hide();
            
            showStatus('success', 'Image generation started with edited prompt');
            
            const statusCell = document.querySelector(`.image-status-cell[data-recipe-id="${recipeId}"]`);
            if (statusCell) {
              statusCell.innerHTML = `<span class="badge bg-warning">⏳ Pending</span>`;
            }
            
            document.getElementById('promptEditForm').reset();
          } else if (data.safetyCheck && data.safetyCheck.blocked) {
            document.getElementById('promptEditAlert').classList.remove('d-none');
            document.getElementById('promptEditBlockedTerms').textContent = 
              data.safetyCheck.terms.join(', ');
            
            document.getElementById('promptEditForm').classList.remove('d-none');
            document.getElementById('promptEditSpinner').classList.add('d-none');
          } else {
            throw new Error(data.error || 'Failed to generate image');
          }
        } catch (error) {
          console.error('Error generating image with edited prompt:', error);
          document.getElementById('promptEditAlert').classList.remove('d-none');
          document.getElementById('promptEditBlockedTerms').textContent = 
            error.message || 'An unknown error occurred';
        } finally {
          promptEditSaveBtn.disabled = false;
          promptEditSaveBtn.innerHTML = 'Generate Image';
          document.getElementById('promptEditForm').classList.remove('d-none');
          document.getElementById('promptEditSpinner').classList.add('d-none');
        }
      });
    }
    
    promptEditModal.addEventListener('hidden.bs.modal', function() {
      document.getElementById('promptEditForm').reset();
      document.getElementById('promptEditAlert').classList.add('d-none');
      document.getElementById('promptEditForm').classList.remove('d-none');
      document.getElementById('promptEditSpinner').classList.add('d-none');
      promptEditSaveBtn.disabled = false;
      promptEditSaveBtn.innerHTML = 'Generate Image';
    });
  }

  // Excel file input handler
  const excelFileInput = document.getElementById('excelFile');
  if (excelFileInput) {
    excelFileInput.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) {
        document.getElementById('excelPreview').classList.add('d-none');
        parsedExcelData = null;
        return;
      }
      
      const allowedTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv'
      ];
      
      if (!allowedTypes.includes(file.type) && !file.name.match(/\.(xlsx|xls|csv)$/i)) {
        showStatus('error', 'Please upload a valid Excel file (.xlsx, .xls) or CSV file.');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          let workbook;
          
          if (file.name.toLowerCase().endsWith('.csv')) {
            const csvData = e.target.result;
            
            console.log('📄 Raw CSV data preview:', csvData.substring(0, 200) + '...');
            
            // ROBUST CSV PARSING: Handle commas within recipe content properly
            try {
              const lines = [];
              let currentLine = '';
              let insideQuotes = false;
              let quoteChar = null;
              
              for (let i = 0; i < csvData.length; i++) {
                const char = csvData[i];
                
                // Handle quote detection
                if ((char === '"' || char === "'") && !insideQuotes) {
                  insideQuotes = true;
                  quoteChar = char;
                  currentLine += char;
                } else if (char === quoteChar && insideQuotes) {
                  // Check for escaped quotes (double quotes)
                  if (i + 1 < csvData.length && csvData[i + 1] === quoteChar) {
                    currentLine += char + char;
                    i++; // Skip the next quote
                  } else {
                    insideQuotes = false;
                    quoteChar = null;
                    currentLine += char;
                  }
                } else if (char === '\n' && !insideQuotes) {
                  if (currentLine.trim()) {
                    lines.push(currentLine.trim());
                  }
                  currentLine = '';
                } else {
                  currentLine += char;
                }
              }
              
              // Add the last line if it exists
              if (currentLine.trim()) {
                lines.push(currentLine.trim());
              }
              
              console.log('📄 CSV Lines parsed:', lines.length);
              lines.forEach((line, index) => {
                console.log(`Line ${index + 1}:`, line.substring(0, 150) + (line.length > 150 ? '...' : ''));
              });
              
              if (lines.length === 0) {
                throw new Error('No data found in CSV');
              }
              
              // Parse header line with proper CSV logic
              const headerLine = lines[0];
              const headers = parseCSVLine(headerLine);
              
              console.log('📋 Headers found:', headers);
              
              // Process data rows with proper CSV parsing
              const rows = [];
              for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim()) {
                  const values = parseCSVLine(line);
                  
                  console.log(`📝 Raw values for row ${i}:`, values.map(v => v.substring(0, 100) + (v.length > 100 ? '...' : '')));
                  
                  const row = {};
                  headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                  });
                  
                  console.log(`📝 Processed row ${i}:`, {
                    keyword: (row.keyword || '').substring(0, 150) + (row.keyword && row.keyword.length > 150 ? '...' : ''),
                    keywordLength: (row.keyword || '').length,
                    imageUrl: (row.imageurl || row.ImageUrl || '').substring(0, 50),
                    otherColumns: Object.keys(row).filter(k => k !== 'keyword' && !k.toLowerCase().includes('imageurl'))
                  });
                  
                  rows.push(row);
                }
              }
              
              parsedExcelData = {
                headers: headers,
                data: rows
              };
              
            } catch (csvError) {
              console.error('❌ Enhanced CSV parsing failed:', csvError);
              showStatus('error', 'Failed to parse CSV. Please ensure your recipe content is properly quoted in the CSV file.');
              return;
            }
          } else {
            workbook = XLSX.read(e.target.result, { type: 'binary' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            if (jsonData.length === 0) {
              showStatus('error', 'The uploaded file appears to be empty.');
              return;
            }
            
            const headers = jsonData[0];
            const data = jsonData.slice(1).filter(row => row.some(cell => cell !== undefined && cell !== '')).map(row => {
              const rowObj = {};
              headers.forEach((header, index) => {
                rowObj[header] = row[index] || '';
              });
              return rowObj;
            });
            
            parsedExcelData = {
              headers: headers,
              data: data
            };
          }
          
          const requiredColumns = ['keyword'];
          const optionalColumns = ['category', 'interests', 'imageurl', 'fullrecipe']; // Added fullrecipe
          const allColumns = [...requiredColumns, ...optionalColumns];
          
          const headerLower = parsedExcelData.headers.map(h => h.toLowerCase());
          const missingRequired = requiredColumns.filter(col => 
            !headerLower.some(h => h.includes(col.toLowerCase()))
          );
          
          if (missingRequired.length > 0) {
            showStatus('error', `Missing required column(s): ${missingRequired.join(', ')}. Please ensure your file has a "Keyword" column.`);
            return;
          }
          
          const columnMap = {};
          allColumns.forEach(col => {
            const matchedHeader = parsedExcelData.headers.find(h => 
              h.toLowerCase().includes(col.toLowerCase())
            );
            if (matchedHeader) {
              columnMap[col] = matchedHeader;
            }
          });
          
          const normalizedData = parsedExcelData.data.map(row => {
            const normalized = {};
            Object.keys(columnMap).forEach(key => {
              const headerName = columnMap[key];
              normalized[key] = row[headerName] || '';
            });
            return normalized;
          }).filter(row => row.keyword && row.keyword.trim());
          
          if (normalizedData.length === 0) {
            showStatus('error', 'No valid data found in the file. Please check that you have keywords in the correct column.');
            return;
          }
          
          parsedExcelData.normalizedData = normalizedData;
          parsedExcelData.columnMap = columnMap;
          
          displayExcelPreview(parsedExcelData);
          
        } catch (error) {
          console.error('Error parsing file:', error);
          showStatus('error', 'Error reading file: ' + error.message);
        }
      };
      
      if (file.name.toLowerCase().endsWith('.csv')) {
        reader.readAsText(file);
      } else {
        reader.readAsBinaryString(file);
      }
    });
  }

  // Function to display Excel preview
  function displayExcelPreview(data) {
    const previewDiv = document.getElementById('excelPreview');
    const headerElement = document.getElementById('excelPreviewHeader');
    const bodyElement = document.getElementById('excelPreviewBody');
    
    if (!previewDiv || !headerElement || !bodyElement) return;
    
    headerElement.innerHTML = '';
    bodyElement.innerHTML = '';
    
    previewDiv.classList.remove('d-none');
    
    const headerRow = document.createElement('tr');
    // SIMPLIFIED: Show recipe type instead of separate columns
    const displayHeaders = ['Recipe Content', 'Type', 'Category', 'Interests', 'Image URL'];
    displayHeaders.forEach(header => {
      const th = document.createElement('th');
      th.textContent = header;
      headerRow.appendChild(th);
    });
    headerElement.appendChild(headerRow);
    
    const previewData = data.normalizedData.slice(0, 5);
    previewData.forEach(row => {
      const tr = document.createElement('tr');
      
      // Recipe Content (truncated for display)
      const contentTd = document.createElement('td');
      const keyword = row.keyword || '';
      contentTd.textContent = keyword.length > 50 ? keyword.substring(0, 47) + '...' : keyword;
      contentTd.title = keyword; // Full text on hover
      contentTd.style.maxWidth = '200px';
      tr.appendChild(contentTd);
      
      // Recipe Type (automatically detected)
      const typeTd = document.createElement('td');
      if (row.isFullRecipe) {
        typeTd.innerHTML = '<span class="badge bg-success">📝 FULL RECIPE</span>';
      } else {
        typeTd.innerHTML = '<span class="badge bg-warning">🤖 AI RECIPE</span>';
      }
      tr.appendChild(typeTd);
      
      // Category
      const categoryTd = document.createElement('td');
      categoryTd.textContent = row.category || '';
      tr.appendChild(categoryTd);
      
      // Interests
      const interestsTd = document.createElement('td');
      const interests = row.interests || '';
      interestsTd.textContent = interests.length > 30 ? interests.substring(0, 27) + '...' : interests;
      if (interests.length > 30) {
        interestsTd.title = interests;
      }
      tr.appendChild(interestsTd);
      
      // Image URL
      const imageUrlTd = document.createElement('td');
      const imageUrl = row.imageurl || '';
      imageUrlTd.textContent = imageUrl.length > 30 ? imageUrl.substring(0, 27) + '...' : imageUrl;
      if (imageUrl.length > 30) {
        imageUrlTd.title = imageUrl;
      }
      tr.appendChild(imageUrlTd);
      
      bodyElement.appendChild(tr);
    });
    
    // Show statistics about detected recipe types
    const fullRecipeCount = data.normalizedData.filter(row => row.isFullRecipe).length;
    const aiRecipeCount = data.normalizedData.length - fullRecipeCount;
    
    showStatus('success', 
      `File parsed successfully! Found ${data.normalizedData.length} total items: ` +
      `${fullRecipeCount} full recipes, ${aiRecipeCount} keywords for AI generation. Preview shows first 5 rows.`
    );
  }

  function detectFullRecipe(text) {
    if (!text || typeof text !== 'string') {
      console.log('❌ Not a string or empty text');
      return false;
    }
    
    console.log('🔍 Analyzing text for recipe detection:', text.substring(0, 100) + '...');
    
    const textLower = text.toLowerCase();
    
    // ENHANCED: Check if it contains ingredient markers (works for single-line too)
    const hasIngredients = textLower.includes('ingredients:') || 
                          textLower.includes('ingredient:') ||
                          /ingredients?\s*[:]/i.test(textLower) ||
                          textLower.includes('what you need:') ||
                          textLower.includes('you will need:');
    
    // ENHANCED: Check if it contains instruction markers (works for single-line too)
    const hasInstructions = textLower.includes('instructions:') || 
                           textLower.includes('instruction:') ||
                           textLower.includes('preparation:') ||
                           textLower.includes('method:') ||
                           textLower.includes('directions:') ||
                           textLower.includes('steps:') ||
                           textLower.includes('how to make:') ||
                           /instructions?\s*[:]/i.test(textLower) ||
                           /preparation\s*[:]/i.test(textLower) ||
                           /directions?\s*[:]/i.test(textLower) ||
                           /method\s*[:]/i.test(textLower);
    
    // Check if it has multiple lines (but don't require it)
    const lines = text.split('\n').filter(line => line.trim());
    const hasMultipleLines = lines.length > 3;
    
    // ENHANCED: Check if it contains measurements (more comprehensive)
    const hasMeasurements = /\b\d+\s*(cup|cups|c\.|tbsp|tsp|tablespoon|tablespoons|teaspoon|teaspoons|lb|lbs|oz|ounce|ounces|pound|pounds|gram|grams|g\.|ml|milliliter|liter|l\.|quart|pint|gallon|kg|kilogram)\b/i.test(text);
    
    // Check for numbered steps (works in single line if steps are numbered)
    const hasNumberedSteps = /\b\d+[\.\)]\s*[A-Z][a-z]/g.test(text) || /step\s*\d+/i.test(text);
    
    // Check for bulleted ingredients (- or • or *) - less useful for single line
    const hasBulletedItems = /^\s*[-•*]\s+/m.test(text);
    
    // ENHANCED: Check for cooking verbs (expanded list)
    const hasCookingVerbs = /\b(preheat|bake|cook|stir|mix|blend|whisk|beat|fold|sauté|sautee|fry|boil|simmer|roast|grill|chop|dice|slice|season|add|combine|heat|cool|chill|serve|pour|remove|grease|flour|dissolve|thicken|melt|frost)\b/i.test(text);
    
    // ENHANCED: Check for temperature mentions
    const hasTemperatures = /\b\d+\s*°?[CF]\b|\b\d+\s*degrees?\b|\b(fahrenheit|celsius)\b/i.test(text);
    
    // ENHANCED: Check for time mentions
    const hasTimeReferences = /\b\d+\s*(minute|minutes|min|hour|hours|hr|hrs|second|seconds|sec)\b/i.test(text);
    
    // NEW: Check for recipe-specific content length (single-line recipes are usually long)
    const hasSubstantialContent = text.length > 200;
    
    // NEW: Check for multiple cooking actions in sequence
    const cookingActionCount = (text.match(/\b(preheat|bake|cook|stir|mix|blend|whisk|beat|fold|sauté|sautee|fry|boil|simmer|roast|grill|chop|dice|slice|season|add|combine|heat|cool|chill|serve|pour|remove|grease|flour|dissolve|thicken|melt|frost)\b/gi) || []).length;
    const hasMultipleCookingActions = cookingActionCount >= 3;
    
    // NEW: Check for ingredient-like patterns (numbers with measurements near food words)
    const ingredientPatterns = /\b\d+\s*(?:cup|cups|tbsp|tsp|tablespoon|teaspoon|lb|oz|gram|ml|liter|kg)s?\s+(?:of\s+)?[a-z]/gi;
    const hasIngredientPatterns = (text.match(ingredientPatterns) || []).length >= 3;
    
    // Log all detection results
    console.log('🔍 Detection Results:', {
      hasIngredients,
      hasInstructions,
      hasMultipleLines,
      hasMeasurements,
      hasNumberedSteps,
      hasBulletedItems,
      hasCookingVerbs,
      hasTemperatures,
      hasTimeReferences,
      hasSubstantialContent,
      hasMultipleCookingActions,
      hasIngredientPatterns,
      cookingActionCount,
      textLength: text.length,
      lineCount: lines.length
    });
    
    // PRIORITY 1: Definitive full recipe detection
    if (hasIngredients && hasInstructions) {
      console.log('✅ Full recipe detected: Has both ingredients and instructions sections');
      return true;
    }
    
    // PRIORITY 2: Single-line recipe with strong indicators
    if (hasSubstantialContent && hasIngredients && hasMeasurements && hasMultipleCookingActions) {
      console.log('✅ Full recipe detected: Single-line recipe with ingredients, measurements, and multiple cooking actions');
      return true;
    }
    
    // PRIORITY 3: Single-line recipe with instructions and strong content
    if (hasSubstantialContent && hasInstructions && hasMeasurements && hasMultipleCookingActions) {
      console.log('✅ Full recipe detected: Single-line recipe with instructions, measurements, and cooking actions');
      return true;
    }
    
    // PRIORITY 4: Recipe with ingredient patterns and cooking actions
    if (hasIngredientPatterns && hasMultipleCookingActions && hasSubstantialContent) {
      console.log('✅ Full recipe detected: Has ingredient patterns and multiple cooking actions');
      return true;
    }
    
    // PRIORITY 5: Multi-line recipe with multiple indicators
    const indicators = [
      hasMultipleLines,
      hasMeasurements,
      hasNumberedSteps,
      hasBulletedItems,
      hasCookingVerbs,
      hasTemperatures,
      hasTimeReferences
    ];
    
    const indicatorCount = indicators.filter(Boolean).length;
    
    if (indicatorCount >= 4 && hasMultipleLines) {
      console.log(`✅ Full recipe detected: ${indicatorCount}/7 indicators present with multiple lines`);
      return true;
    }
    
    // PRIORITY 6: Any recipe with measurements, cooking verbs, and substantial content
    if (hasMeasurements && hasCookingVerbs && hasSubstantialContent && (hasTemperatures || hasTimeReferences)) {
      console.log('✅ Full recipe detected: Has measurements, cooking verbs, substantial content, and temperature/time references');
      return true;
    }
    
    // Log detection results for debugging
    console.log(`🤖 AI recipe detected: ${indicatorCount}/7 traditional indicators, ${cookingActionCount} cooking actions for "${text.substring(0, 50)}..."`);
    
    return false;
  }

  // ENHANCED: Helper function to extract recipe title
  function extractRecipeTitle(recipeText) {
    if (!recipeText || typeof recipeText !== 'string') {
      return 'Recipe';
    }
    
    console.log('🏷️ Extracting title from recipe:', recipeText.substring(0, 100) + '...');
    
    // Method 1: Try to find content before "Ingredients:" (works for single-line)
    const ingredientsMatch = recipeText.match(/^(.*?)\s*Ingredients?\s*[:]/i);
    if (ingredientsMatch && ingredientsMatch[1].trim()) {
      const title = ingredientsMatch[1].trim();
      console.log('✅ Title extracted using Ingredients marker:', title);
      return title;
    }
    
    // Method 2: Try to find content before "Instructions:" 
    const instructionsMatch = recipeText.match(/^(.*?)\s*Instructions?\s*[:]/i);
    if (instructionsMatch && instructionsMatch[1].trim()) {
      const title = instructionsMatch[1].trim();
      console.log('✅ Title extracted using Instructions marker:', title);
      return title;
    }
    
    // Method 3: For multi-line recipes, use first line
    const lines = recipeText.split('\n').filter(line => line.trim());
    if (lines.length > 1) {
      const firstLine = lines[0].trim();
      // Make sure it's not just "Ingredients:" or "Instructions:"
      if (firstLine && !firstLine.toLowerCase().match(/^(ingredients?|instructions?)\s*[:]*$/)) {
        console.log('✅ Title extracted from first line:', firstLine);
        return firstLine;
      }
    }
    
    // Method 4: Try to extract first sentence (for single-line recipes)
    const sentences = recipeText.split(/[.!?]/).filter(s => s.trim());
    if (sentences.length > 0) {
      const firstSentence = sentences[0].trim();
      // Make sure it's reasonable length for a title (not too long)
      if (firstSentence.length > 5 && firstSentence.length < 100) {
        console.log('✅ Title extracted from first sentence:', firstSentence);
        return firstSentence;
      }
    }
    
    // Method 5: Fallback - take first reasonable chunk of words
    const words = recipeText.trim().split(/\s+/);
    if (words.length >= 3) {
      // Take first 3-8 words as title
      const titleWords = words.slice(0, Math.min(8, words.length));
      const title = titleWords.join(' ');
      
      // Stop at "Ingredients" if it appears
      const beforeIngredients = title.split(/\s*Ingredients?\s*/i)[0];
      if (beforeIngredients.trim()) {
        console.log('✅ Title extracted from first words:', beforeIngredients.trim());
        return beforeIngredients.trim();
      }
    }
    
    // Ultimate fallback
    console.log('⚠️ Using fallback title');
    return 'Recipe';
  }

  // Handle Excel tab submission
  function handleExcelTabSubmission() {
    if (!parsedExcelData || !parsedExcelData.normalizedData) {
      showStatus('error', 'Please upload and preview an Excel file first.');
      return null;
    }
    
    const defaultCategory = document.getElementById('defaultCategory').value;
    const defaultInterests = document.getElementById('defaultInterests').value;
    const defaultImageUrl = document.getElementById('excelDefaultImageUrl').value;
    
    // Process each row - same logic as manual entry
    const keywordsToAdd = parsedExcelData.normalizedData.map(row => {
      const keywordText = row.keyword.trim();
      
      // Use the same detection logic as manual entry
      const isFullRecipe = detectFullRecipe(keywordText);
      
      let keyword;
      
      if (isFullRecipe) {
        // ENHANCED: Use the same title extraction logic as manual entry
        keyword = extractRecipeTitle(keywordText);
      } else {
        // For simple keywords, use the input as-is
        keyword = keywordText;
      }
      
      // DEBUG: Log what we're processing
      console.log(`Excel processing: "${keyword}" - Full recipe: ${isFullRecipe}`);
      if (isFullRecipe) {
        console.log(`  Recipe length: ${keywordText.length} characters`);
        console.log(`  Extracted title: "${keyword}"`);
        console.log(`  First 100 chars: ${keywordText.substring(0, 100)}...`);
      }
      
      return {
        keyword: keyword,
        full_recipe: isFullRecipe ? keywordText : null, // Store full recipe if detected
        category: row.category && row.category.trim() ? row.category.trim() : defaultCategory,
        interests: row.interests && row.interests.trim() ? row.interests.trim() : defaultInterests,
        image_url: row.imageurl && row.imageurl.trim() ? row.imageurl.trim() : defaultImageUrl
      };
    });
    
    // DEBUG: Log the final processed data
    console.log('=== EXCEL SUBMISSION DEBUG ===');
    console.log(`Total items: ${keywordsToAdd.length}`);
    const fullRecipeCount = keywordsToAdd.filter(item => item.full_recipe).length;
    console.log(`Full recipes: ${fullRecipeCount}`);
    console.log(`AI recipes: ${keywordsToAdd.length - fullRecipeCount}`);
    
    keywordsToAdd.slice(0, 3).forEach((item, index) => {
      console.log(`Item ${index + 1}:`, {
        keyword: item.keyword,
        has_full_recipe: !!item.full_recipe,
        full_recipe_preview: item.full_recipe ? item.full_recipe.substring(0, 50) + '...' : 'None'
      });
    });
    console.log('=== END EXCEL SUBMISSION DEBUG ===');
    
    return {
      keywords: keywordsToAdd
    };
  }

  // Add Keywords form submission
  const addKeywordsForm = document.getElementById('addKeywordsForm');
  if (addKeywordsForm) {
    addKeywordsForm.addEventListener('submit', function(event) {
      event.preventDefault();
      
      const addBtn = document.getElementById('addBtn');
      if (addBtn) {
        addBtn.disabled = true;
        addBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Adding...';
      }
      
      let formData;
      const activeTab = getCurrentActiveTab();
      
      if (activeTab === 'manual-tab') {
        const keywords = document.getElementById('keywords').value.trim();
        const defaultCategory = document.getElementById('defaultCategory').value;
        const defaultInterests = document.getElementById('defaultInterests').value;
        const imageUrl = document.getElementById('imageUrl').value.trim();
        
        if (!keywords) {
          showStatus('error', 'Please enter at least one recipe.');
          if (addBtn) {
            addBtn.disabled = false;
            addBtn.innerHTML = 'Add Keywords';
          }
          return;
        }
        
        // Split by "---" instead of lines to handle full recipes
        const recipesList = keywords.split('---')
          .map(recipe => recipe.trim())
          .filter(recipe => recipe.length > 0);
        
       formData = {
    keywords: recipesList.map(recipeInput => {
      // Extract the first line as the title/keyword
      const lines = recipeInput.split('\n').filter(line => line.trim());
      const keyword = lines.length > 0 ? lines[0].trim() : 'Recipe';
      
      // DETECT if this is a full recipe or just a keyword
      const isFullRecipe = detectFullRecipe(recipeInput);
      
      return {
        keyword: keyword,
        full_recipe: isFullRecipe ? recipeInput : null, // Only store if full recipe
        category: defaultCategory,
        interests: defaultInterests,
        image_url: imageUrl
      };
    })
  };
        
      } else if (activeTab === 'excel-tab') {
        formData = handleExcelTabSubmission();
        if (!formData) {
          if (addBtn) {
            addBtn.disabled = false;
            addBtn.innerHTML = 'Add Keywords';
          }
          return;
        }
        
      } else if (activeTab === 'pinclicks-tab') {
        if (!analyzedPinclicksResults) {
          showStatus('error', 'Please analyze the CSV file first.');
          if (addBtn) {
            addBtn.disabled = false;
            addBtn.innerHTML = 'Add Keywords';
          }
          return;
        }
        
        formData = {
          keywords: analyzedPinclicksResults
        };
      }
      
      // DEBUG: Log what we're about to send
      console.log('=== DEBUG: About to submit ===');
      console.log('Active tab:', activeTab);
      console.log('Form data:', JSON.stringify(formData, null, 2));
      console.log('Number of items:', formData.keywords.length);
      formData.keywords.forEach((item, index) => {
        console.log(`Item ${index + 1}:`, {
          keyword: item.keyword,
          has_full_recipe: !!item.full_recipe,
          full_recipe_length: item.full_recipe ? item.full_recipe.length : 0
        });
      });
      console.log('=== END DEBUG ===');

      fetch('/api/keywords/add', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
      })
      .then(response => {
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          return response.text().then(text => {
            console.error('Server returned non-JSON response:', text);
            throw new Error(`Server error: ${response.status} ${response.statusText}. Response was HTML instead of JSON. Check server logs.`);
          });
        }
        
        return response.json();
      })
      .then(data => {
        if (data.success) {
          showStatus('success', data.message || `Successfully added ${formData.keywords.length} recipes!`);
          
          addKeywordsForm.reset();
          parsedExcelData = null;
          document.getElementById('excelPreview').classList.add('d-none');
          
          setTimeout(() => {
            window.location.href = '/keywords';
          }, 1500);
        } else {
          throw new Error(data.message || 'Failed to add recipes');
        }
      })
      .catch(error => {
        console.error('Error adding recipes:', error);
        showStatus('error', error.message || 'An unknown error occurred');
      })
      .finally(() => {
        if (addBtn) {
          addBtn.disabled = false;
          addBtn.innerHTML = 'Add Keywords';
        }
      });
    });
  }
   
  // ENHANCED: Auto-start monitoring for keywords with "CHECKING..." status
  function startAutoImageMonitoring() {
    console.log('🔍 Checking for keywords with CHECKING status that need monitoring...');
    
    // Find all image badges that show "CHECKING..."
    const checkingBadges = document.querySelectorAll('[data-badge="image"]:not([data-recipe-id=""])');
    
    let startedMonitoring = 0;
    
    checkingBadges.forEach(badge => {
      // Only monitor badges that show "CHECKING..." text
      if (badge.textContent.includes('CHECKING')) {
        const recipeId = badge.getAttribute('data-recipe-id');
        const keywordCard = badge.closest('.keyword-card');
        const keywordId = keywordCard ? keywordCard.getAttribute('data-id') : null;
        
        if (recipeId && keywordId && recipeId !== 'null' && recipeId !== 'undefined') {
          console.log(`🖼️ Auto-starting monitoring for keyword ${keywordId}, recipe ${recipeId}`);
          startSmartImageMonitoring(recipeId, keywordId);
          startedMonitoring++;
        } else {
          console.log(`⚠️ Skipping badge with invalid IDs: recipe=${recipeId}, keyword=${keywordId}`);
        }
      }
    });
    
    if (startedMonitoring > 0) {
      console.log(`✅ Started automatic monitoring for ${startedMonitoring} keywords with CHECKING status`);
    } else {
      console.log('ℹ️ No keywords found with CHECKING status that need monitoring');
    }
  }

  // Check for ongoing processing on page load and restore progress bar
  async function checkAndRestoreProgressBar() {
    // Look for keywords that are currently processing
    const processingKeywords = document.querySelectorAll('.keyword-card[data-status="processing"]');
    
    if (processingKeywords.length > 0) {
      console.log(`Found ${processingKeywords.length} keywords still processing after page refresh`);
      
      // Get the first processing keyword to determine content type
      const firstKeyword = processingKeywords[0];
      const keywordId = firstKeyword.getAttribute('data-id');
      
      // Get stored content option or default to 'all'
      const contentOption = localStorage.getItem('currentContentOption') || 'all';
      const storedStartTime = localStorage.getItem('processingStartTime');
      
      // Show progress bar
      const progressElement = document.getElementById('processingProgress');
      if (progressElement) {
        progressElement.classList.remove('d-none');
        
        // Initialize progress elements
        document.getElementById('progressCount').textContent = `0 / ${processingKeywords.length}`;
        document.getElementById('progressPercentage').textContent = '0%';
        document.getElementById('successCount').textContent = '0';
        document.getElementById('failedCount').textContent = '0';
        document.getElementById('remainingCount').textContent = processingKeywords.length;
        document.getElementById('elapsedTime').textContent = '00:00';
        document.getElementById('progressText').textContent = 'Restored processing status after page refresh...';
        document.getElementById('currentKeyword').textContent = '';
        
        // Reset workflow steps for the detected content type
        resetWorkflowSteps(contentOption);
        
        // Start monitoring the processing keywords
        const keywordIds = Array.from(processingKeywords).map(card => card.getAttribute('data-id'));
        console.log('Resuming monitoring for keywords:', keywordIds);
        
        // Start batch monitoring (simplified - no database verification needed)
        console.log('📊 Starting resume monitoring for HTML processing keywords');
        startBatchStatusMonitoring(keywordIds);
        
        // Start timer (use stored start time if available)
        const startTime = storedStartTime ? parseInt(storedStartTime) : Date.now();
        window.processingTimeInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          document.getElementById('elapsedTime').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
        
        // Show a status message
        showStatus('info', `Resumed monitoring ${processingKeywords.length} keywords that were processing before page refresh.`);
      }
    }
  }

  // Run initial checks and formatting  
  setTimeout(() => {
    debugImageStatusSetup();
    // checkImageStatus(); // DISABLED - Caused immediate "failed" status
  }, 1000);
  
  // IMMEDIATE: Start monitoring right away for faster response
  startAutoImageMonitoring();
  
  // BACKUP: Also check again after 1 second in case page wasn't ready
  setTimeout(() => {
    startAutoImageMonitoring();
  }, 1000);
  
  formatDates();
  sortRowsByDate();
  
  // Initialize counts
  updateSelectedCount();
  
  // Check for ongoing processing and restore progress bar if needed
  checkAndRestoreProgressBar().catch(error => {
    console.error('Error in checkAndRestoreProgressBar:', error);
  });
  
  // DISABLED: Old automatic monitoring that caused "failed" status bugs
  // startImageStatusMonitoring();


});
</script>